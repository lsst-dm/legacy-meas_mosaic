#!/usr/bin/env python

import os
import math
import numpy

import matplotlib
matplotlib.use('Agg')
import matplotlib.pyplot as plt
import matplotlib.mlab as mlab
import multiprocessing
from lsst.pex.logging import getDefaultLog

import lsst.afw.cameraGeom              as cameraGeom
import lsst.afw.geom                    as afwGeom
import lsst.afw.image                   as afwImage
import lsst.afw.table                   as afwTable
import lsst.afw.coord                   as afwCoord
import lsst.afw.math                    as afwMath
import lsst.pex.config                  as pexConfig
import lsst.pipe.base                   as pipeBase
import lsst.meas.algorithms             as measAlg
import lsst.meas.astrom                 as measAstrom
import lsst.meas.mosaic.mosaicLib       as measMosaic
from lsst.pipe.tasks.colorterms import ColortermLibrary

from lsst.meas.base.forcedPhotCcd import PerTractCcdDataIdContainer

# Use LaTeX to render figure captions? Requires dvipng (not available on lsst-dev).
USETEX=False

class MosaicRunner(pipeBase.TaskRunner):
    """Subclass of TaskRunner for MosaicTask

    MosaicTask.run() takes a number of arguments, one of which is a list of dataRefs
    extracted from the command line (whereas most CmdLineTasks' run methods take
    single dataRef, are are called repeatedly).  This class transforms the processed
    arguments generated by the ArgumentParser into the arguments expected by
    MosaicTask.run().

    See pipeBase.TaskRunner for more information, but note that the multiprocessing
    code path does not apply, because MosaicTask.canMultiprocess == False.
    """

    @staticmethod
    def getTargetList(parsedCmd, **kwargs):
        # organize data IDs by tract
        refListDict = {}
        for ref in parsedCmd.id.refList:
            refListDict.setdefault(ref.dataId["tract"], []).append(ref)
        # we call run() once with each tract
        return [(parsedCmd.butler.mapper.getCameraName(),
                 parsedCmd.butler,
                 tract,
                 refListDict[tract],
                 parsedCmd.debug,
                 parsedCmd.diagDir,
                 parsedCmd.diagnostics,
                 parsedCmd.snapshots,
                 parsedCmd.numCoresForReadSource,
                 parsedCmd.readTimeout,
                 ) for tract in sorted(refListDict.keys())]

    def __call__(self, args):
        task = self.TaskClass(config=self.config, log=self.log)
        result = task.run(*args)

class MosaicConfig(pexConfig.Config):
    nBrightest = pexConfig.Field(
        doc="number of stars used for fitting per exposure",
        dtype=int,
        default=0)
    cellSize = pexConfig.Field(
        doc="size of cell used to select stars (pixels)",
        dtype=int,
        default=512,
        check = lambda x: x >= 128)
    nStarPerCell = pexConfig.Field(
        doc = "number of stars per cell",
        dtype = int,
        default = 5)
    radXMatch = pexConfig.RangeField(
        doc="radius to cross-match objects between expsoures in arcsec",
        dtype=float,
        default=1.0, min=0.1)
    fittingOrder = pexConfig.RangeField(
        doc="fitting order",
        dtype=int,
        default=5, min=2)
    internalFitting = pexConfig.Field(
        doc="Use stars without catalog matching for fitting?",
        dtype=bool,
        default=True)
    solveCcd = pexConfig.Field(
        doc="Solve CCD alignment?",
        dtype=bool,
        default=True)
    allowRotation = pexConfig.Field(
        doc="Solve rotation?",
        dtype=bool,
        default=True)
    catRMS = pexConfig.Field(
        doc="Positional error in reference catalog (degree)",
        dtype=float,
        default=0.040/3600.)
    chebyshev = pexConfig.Field(
        doc="Use Chebyshev polynomials for flux fitting?",
        dtype=bool,
        default=True)
    fluxFitOrder = pexConfig.RangeField(
        doc="flux fitting order",
        dtype=int,
        default=5, min=0)
    fluxFitAbsolute = pexConfig.Field(
        doc="Fit to catalog flux?",
        dtype=bool,
        default=False)
    fluxFitSolveCcd = pexConfig.Field(
        doc="Solve for per CCD flux scale?",
        dtype=bool,
        default=False)
    minNumMatch = pexConfig.RangeField(
        doc="Minimum number of matches in CCD to be used.",
        dtype=int,
        default=0, min=0)
    numSourceMerge = pexConfig.RangeField(
        doc="Minimum number of sources to be merged.",
        dtype=int,
        default=2, min=0)
    requireTractOverlap = pexConfig.Field(
        doc="If True, ignore CCDs that don't overlap the current tract",
        dtype=bool,
        default=True)
    clipSourcesOutsideTract = pexConfig.Field(
        doc="If True, unmatched sources outside of tract will not be used as constraints",
        dtype=bool,
        default=True)
    astrom = pexConfig.ConfigField(dtype=measAstrom.ANetBasicAstrometryConfig, doc="Configuration for readMatches")
    doColorTerms = pexConfig.Field(dtype=bool, default=True, doc="Apply color terms as part of solution?")
    doSolveWcs = pexConfig.Field(dtype=bool, default=True, doc="Solve distortion and wcs?")
    doSolveFlux = pexConfig.Field(dtype=bool, default=True, doc="Solve flux correction?")
    commonFluxCorr = pexConfig.Field(dtype=bool, default=True, doc="Is flux correction common between exposures?")
    colorterms = pexConfig.ConfigField(dtype=ColortermLibrary, doc="Color term library")
    photoCatName = pexConfig.Field(dtype=str, optional=True,
        doc="Name of photometric reference catalog; used to select a color term dict in colorterm library.")
    includeSaturated = pexConfig.Field(
        doc="If True, saturated objects will also be used for mosaicking.",
        dtype=bool,
        default=False)
    extendednessForStarSelection = pexConfig.Field(
        doc="Extendedness for star selection",
        dtype=str,
        default='base_ClassificationExtendedness_value')
    saturatedForStarSelection = pexConfig.Field(
        doc="Saturated flag for star selection",
        dtype=str,
        default='base_PixelFlags_flag_saturated')
    psfStarForStarSelection = pexConfig.Field(
        doc="PSF star flag for star selection",
        dtype=str,
        default='calib_psfUsed')

class SourceReader(object):
    """ Object to read source catalog.
    """

    def __init__(self, cterm, config):
        self.cterm  = cterm
        self.config = config

    def selectStars(self, sources, includeSaturated=False):
        """ Return a list of stellar like objects selected from input sources

        Stellarity will be judged based mainly on extendedness (classification.extendedness).
        If an object is used to determine PSF (calib.psf.used == True), it will be included.
        Saturated objects (flags.pixel.saturated.any) will not be included as a default.
        """

        if len(sources) == 0:
            return []

        psfKey = None                       # Table key for classification.psfstar
        if isinstance(sources, afwTable.ReferenceMatchVector) or isinstance(sources[0], afwTable.ReferenceMatch):
            sourceList = [s.second for s in sources]
            psfKey = sourceList[0].schema.find(self.config.psfStarForStarSelection).getKey()
        else:
            sourceList = sources

        schema = sourceList[0].schema
        extKey = schema.find(self.config.extendednessForStarSelection).getKey()
        satKey = schema.find(self.config.saturatedForStarSelection).getKey()

        stars = []
        for includeSource, checkSource in zip(sources, sourceList):
            star = (psfKey is not None and checkSource.get(psfKey)) or checkSource.get(extKey) < 0.5
            saturated = checkSource.get(satKey)
            if star and (includeSaturated or not saturated):
                stars.append(includeSource)
        return stars

    def setCatFlux(self, m, f, key):
        m.first.set(key, f)
        return m

    def readSrc(self, dataRef):
        """ Read source catalog etc for input dataRef

        The followings are returned
        Source catalog, matched list, and wcs will be read from 'src', 'icMatchFull', and 'calexp_md', respectively.
        If color transformation is given, it will be applied to reference flux of matched list.
        Source catalog and matched list will be converted to measMosaic's Source and SourceMatch and returned.
        The number of 'Source's in each cell defined by config.cellSize will be limited to brightest config.nStarPerCell.
        """

        self.log = getDefaultLog()

        dataId = dataRef.dataId

        try:
            if not dataRef.datasetExists('src'):
                raise RuntimeError("no data for src %s" % (dataId))
            if not dataRef.datasetExists('calexp_md'):
                raise RuntimeError("no data for calexp_md %s" % (dataId))

            calexp_md = dataRef.get('calexp_md', immediate=True)
            wcs = afwImage.makeWcs(calexp_md)

            sources = dataRef.get('src', immediate=True, flags=afwTable.SOURCE_IO_NO_FOOTPRINTS)

            refObjLoader = measAstrom.LoadAstrometryNetObjectsTask(measAstrom.LoadAstrometryNetObjectsTask.ConfigClass())
            icMatch = dataRef.get('icMatch', immediate=True)
            icSrc = dataRef.get('icSrc', immediate=True)
            matches = refObjLoader.joinMatchListWithCatalog(icMatch, icSrc)

            matches = [m for m in matches if m.first is not None]
            refSchema = matches[0].first.schema if matches else None
            if self.cterm is not None and len(matches) != 0:
                # Add a "flux" field to the input schema of the first element
                # of the match and populate it with a colorterm correct flux.
                mapper = afwTable.SchemaMapper(refSchema)
                for key, field in refSchema:
                    mapper.addMapping(key)
                key_f = mapper.editOutputSchema().addField("flux", type=float, doc="Reference flux")
                table = afwTable.SimpleTable.make(mapper.getOutputSchema())
                table.preallocate(len(matches))
                for match in matches:
                    newMatch = table.makeRecord()
                    newMatch.assign(match.first, mapper)
                    match.first = newMatch

                key_p = refSchema.find(self.cterm.primary).key
                key_s = refSchema.find(self.cterm.secondary).key
                refFlux1 = numpy.array([m.first.get(key_p) for m in matches])
                refFlux2 = numpy.array([m.first.get(key_s) for m in matches])
                refMag1 = -2.5*numpy.log10(refFlux1)
                refMag2 = -2.5*numpy.log10(refFlux2)
                refMag = self.cterm.transformMags(refMag1, refMag2)
                refFlux = numpy.power(10.0, -0.4*refMag)
                matches = [self.setCatFlux(m, f, key_f) for m, f in zip(matches, refFlux) if f == f]
            else:
                filterName = afwImage.Filter(calexp_md).getName()
                refFluxField = measAlg.getRefFluxField(refSchema, filterName)
                refSchema.getAliasMap().set("flux", refFluxField)

            selSources = self.selectStars(sources, self.config.includeSaturated)
            selMatches = self.selectStars(matches, self.config.includeSaturated)

            retSrc = list()
            retMatch = list()

            if len(selMatches) > self.config.minNumMatch:
                naxis1, naxis2 = calexp_md.get('NAXIS1'), calexp_md.get('NAXIS2')
                bbox = afwGeom.Box2I(afwGeom.Point2I(0,0), afwGeom.Extent2I(naxis1, naxis2))
                cellSet = afwMath.SpatialCellSet(bbox, self.config.cellSize, self.config.cellSize)
                for s in selSources:
                    if numpy.isfinite(s.getRa().asDegrees()): # get rid of NaN
                        src = measMosaic.Source(s)
                        src.setExp(dataId['visit'])
                        src.setChip(dataId['ccd'])
                        try:
                            cellSet.insertCandidate(measMosaic.SpatialCellSource(src))
                        except:
                            self.log.info('visit=%d ccd=%d x=%f y=%f' % (dataRef.dataId['visit'], dataRef.dataId['ccd'], src.getX(), src.getY()) + ' bbox=' + str(bbox))
                for cell in cellSet.getCellList():
                    cell.sortCandidates()
                    for i, cand in enumerate(cell):
                        cand = measMosaic.cast_SpatialCellSource(cand)
                        src = cand.getSource()
                        retSrc.append(src)
                        if i == self.config.nStarPerCell-1:
                            break
                for m in selMatches:
                    if m.first is not None and m.second is not None:
                        match = measMosaic.SourceMatch(measMosaic.Source(m.first, wcs), measMosaic.Source(m.second))
                        match.second.setExp(dataId['visit'])
                        match.second.setChip(dataId['ccd'])
                        retMatch.append(match)
            else:
                self.log.info('%8d %3d : %d/%d matches  Suspicious to wrong match. Ignore this CCD' % (dataRef.dataId['visit'], dataRef.dataId['ccd'], len(selMatches), len(matches)))

        except Exception as e:
            self.log.warn("Failed to read %s: %s" % (dataId, e))
            return dataId, [None, None, None]

        return dataId, [retSrc, retMatch, wcs]

class Worker(object):
    """ Worker object for multiprocessing
    """
    def __init__(self, verbose=False):
        self.verbose = verbose

    def __call__(self, payload):
        sourceReader, dataRef = payload

        return sourceReader.readSrc(dataRef)

class MosaicTask(pipeBase.CmdLineTask):

    RunnerClass = MosaicRunner
    canMultiprocess = False
    ConfigClass = MosaicConfig
    _DefaultName = "Mosaic"

    @classmethod
    def _makeArgumentParser(cls):
        parser = pipeBase.ArgumentParser(name=cls._DefaultName)
        parser.add_id_argument("--id", "wcs", help="data ID, with raw CCD keys + tract",
                               ContainerClass=PerTractCcdDataIdContainer)
        parser.add_argument("--diagDir", default=".", help="Directory in which to dump diagnostics")
        parser.add_argument("--diagnostics", default=False, action="store_true",
                            help="Save diagnostics plots?")
        parser.add_argument("--snapshots", default=False, action="store_true",
                            help="Save snapshots of ObsVecs during iteration?")
        parser.add_argument("--numCoresForReadSource", default=1, type=int,
                            help="Number of cores to be used for reading source catalog")
        parser.add_argument("--readTimeout", default=9999, type=float,
                            help="Timeout (sec) for reading inputs with multiple processes")
        return parser

    def readCcd(self, dataRefList):
        self.log.info("Reading CCD info ...")

        ccds = measMosaic.CcdSet()
        for dataRef in dataRefList:
            if not dataRef.dataId['ccd'] in ccds.keys():
                ccd = dataRef.getButler().mapper.camera[int(dataRef.dataId['ccd'])]
                ccds[dataRef.dataId['ccd']] = ccd
        
        return ccds
        
    def getWcsForCcd(self, dataRef):

        try:
            md = dataRef.get('calexp_md')
            return afwImage.makeWcs(md)
        except Exception as e:
            print "Failed to read: %s for %s" % (e, dataRef.dataId)
            return None

    def readWcs(self, dataRefList, ccdSet):
        
        self.log.info("Reading WCS ...")

        wcsDic = measMosaic.WcsDic()
        for dataRef in dataRefList:
            if not dataRef.dataId['visit'] in wcsDic.keys():
                if (dataRef.datasetExists('calexp') and
                    dataRef.datasetExists('src') and
                    dataRef.datasetExists('icSrc') and
                    dataRef.datasetExists('icMatch')):
                    wcs = self.getWcsForCcd(dataRef)
                    ccd = ccdSet[dataRef.dataId['ccd']]
                    offset = measMosaic.getCenterInFpPixels(ccd)
                    wcs.shiftReferencePixel(offset[0], offset[1])
                    wcsDic[dataRef.dataId['visit']] = wcs

        return wcsDic

    def removeNonExistCcd(self, dataRefList, ccdSet):
        num = dict()
        for dataRef in dataRefList:
            if not dataRef.dataId['ccd'] in num.keys():
                num[dataRef.dataId['ccd']] = 0
            if (dataRef.datasetExists('calexp') and
                dataRef.datasetExists('src') and
                dataRef.datasetExists('icSrc') and
                dataRef.datasetExists('icMatch')):
                num[dataRef.dataId['ccd']] += 1

        for ichip in ccdSet.keys():
            if num[ichip] == 0:
                ccdSet.erase(ichip)

    def readCatalog(self, dataRefList, ct=None, numCoresForReadSource=1, readTimeout=9999, verbose=False):
        self.log.info("Reading catalogs ...")
        self.log.info("Use %d cores for reading source catalog" % (numCoresForReadSource))

        sourceSet = measMosaic.SourceGroup()
        matchList = measMosaic.SourceMatchGroup()

        sourceReader = SourceReader(ct, self.config)

        params = list()
        for dataRef in dataRefList:
            params.append((sourceReader, dataRef))

        if numCoresForReadSource > 1:
            pool = multiprocessing.Pool(processes=numCoresForReadSource)
            worker = Worker()
            resultList = pool.map_async(worker, params).get(readTimeout)
        else:
            resultList = list()
            for p in params:
                sourceReader, dataRef = p
                resultList.append(sourceReader.readSrc(dataRef))

        ssVisit = dict()
        mlVisit = dict()
        dataRefListUsed = list()
        for dataId, result in resultList:
            sources, matches, wcs = result
            if sources is not None:
                if not dataId['visit'] in ssVisit.keys():
                    ssVisit[dataId['visit']] = list()
                    mlVisit[dataId['visit']] = list()

                for s in sources:
                    ssVisit[dataId['visit']].append(s)

                for m in matches:
                    mlVisit[dataId['visit']].append(m)

                for dataRef in dataRefList:
                    if dataRef.dataId == dataId:
                        dataRefListUsed.append(dataRef)

        for visit in ssVisit.keys():
            sourceSet.push_back(ssVisit[visit])
            matchList.push_back(mlVisit[visit])

        return sourceSet, matchList, dataRefListUsed

    def countObsInSourceGroup(self, sg):
        num = 0
        for s in sg:
            num += (len(s) - 1)

        return num

    def mergeCatalog(self, sourceSet, matchList, ccdSet, d_lim):

        self.log.info("Creating kd-tree for matched catalog ...")
        self.log.info("len(matchList) = "+str(len(matchList))+" "+
                      str([len(matches) for matches in matchList]))
        rootMat = measMosaic.kdtreeMat(matchList)
        allMat = rootMat.mergeMat()
        self.log.info("# of allMat : %d" % self.countObsInSourceGroup(allMat))
        self.log.info('len(allMat) = %d' % len(allMat))
    
        self.log.info("Creating kd-tree for source catalog ...")
        self.log.info('len(sourceSet) = '+str(len(sourceSet))+" "+
                      str([len(sources) for sources in sourceSet]))
        rootSource = measMosaic.kdtreeSource(sourceSet, rootMat, ccdSet, d_lim)
        allSource = rootSource.mergeSource(self.config.numSourceMerge)
        self.log.info("# of allSource : %d" % self.countObsInSourceGroup(allSource))
        self.log.info('len(allSource) = %d' % len(allSource))

        return allMat, allSource

    def writeNewWcs(self, dataRefList):
        self.log.info("Write New WCS ...")
        exp = afwImage.ExposureI(0,0)
        for dataRef in dataRefList:
            iexp = dataRef.dataId['visit']
            ichip = dataRef.dataId['ccd']
            c = measMosaic.convertCoeff(self.coeffSet[iexp], self.ccdSet[ichip]);
            wcs = measMosaic.wcsFromCoeff(c);
            exp.setWcs(wcs)
            try:
                dataRef.put(exp, 'wcs')
            except Exception as e:
                print "failed to write something: %s" % (e)

    def writeFcr(self, dataRefList):
        self.log.info("Write Fcr ...")
        M_LN10 = math.log(10)
        dmag = list()
        for m in self.matchVec:
            if (m.good == True and m.mag != -9999 and m.jstar != -1 and
                m.mag0 != -9999 and m.mag_cat != -9999):
                mag = m.mag
                mag0 = m.mag0
                mag_cat = m.mag_cat
                exp_cor = -2.5 * math.log10(self.fexp[m.iexp])
                chip_cor = -2.5 * math.log10(self.fchip[m.ichip])
                gain_cor = self.ffpSet[m.iexp].eval(m.u, m.v)
                mag_cor = mag + exp_cor + chip_cor + gain_cor
                dmag.append(mag_cor - mag_cat)
        std, mean, n  = self.clippedStd(numpy.array(dmag), 3)
        for dataRef in dataRefList:
            iexp = dataRef.dataId['visit']
            ichip = dataRef.dataId['ccd']
            try:
                x0 = self.coeffSet[iexp].x0
                y0 = self.coeffSet[iexp].y0
            except:
                x0 = 0.0
                y0 = 0.0
            newP = measMosaic.convertFluxFitParams(measMosaic.FluxFitParams(self.ffpSet[iexp]),
                                                   self.ccdSet[ichip], x0, y0)
            metadata = measMosaic.metadataFromFluxFitParams(newP)
            exp = afwImage.ExposureI(0,0)
            exp.getMetadata().combine(metadata)
            scale = self.fexp[iexp] * self.fchip[ichip]
            calib = afwImage.Calib()
            calib.setFluxMag0(1.0/scale, 1.0/scale*std*M_LN10*0.4)
            exp.setCalib(calib)
            try:
                dataRef.put(exp, 'fcr')
            except Exception as e:
                print "failed to write something: %s" % (e)

    def getExtent(self, matchVec):
        u_max = float("-inf")
        v_max = float("-inf")
        for m in matchVec:
            if (math.fabs(m.u) > u_max):
                u_max = math.fabs(m.u)
            if (math.fabs(m.v) > v_max):
                v_max = math.fabs(m.v)

        return u_max, v_max

    def plotCcd(self, coeffx0=0, coeffy0=0):
        for ccd in self.ccdSet.values():
            w = measMosaic.getWidth(ccd)
            h = measMosaic.getHeight(ccd)
            us = list()
            vs = list()
            for x, y in zip([0, w, w, 0, 0], [0, 0, h, h, 0]):
                xy = afwGeom.Point2D(x, y)
                u, v = measMosaic.detPxToFpPx(ccd, xy)
                us.append(u)
                vs.append(v)
            plt.plot(us, vs, 'k-')

    def plotJCont(self, iexp):
        coeff = self.coeffSet[iexp]

        scale = coeff.pixelScale()
        deg2pix = 1. / scale

        delta = 300.
        if (self.ccdSet.size() >= 100):
            x = numpy.arange(-18000., 18000., delta)
            y = numpy.arange(-18000., 18000., delta)
            levels = numpy.linspace(0.81, 1.02, 36)
        else:
            x = numpy.arange(-6000., 6000., delta)
            y = numpy.arange(-6000., 6000., delta)
            levels = numpy.linspace(0.88, 1.02, 36)
        X, Y = numpy.meshgrid(x, y)
        Z = numpy.zeros((len(X),len(Y)))

        for j in range(len(Y)):
            for i in range(len(X)):
                Z[i][j] = coeff.detJ(X[i][j], Y[i][j]) * deg2pix ** 2

        plt.clf()
        plt.contourf(X, Y, Z, levels=levels)
        plt.colorbar()
        plt.title('%d' % (iexp))

        self.plotCcd(coeff.x0, coeff.y0)

        plt.savefig(os.path.join(self.outputDir, "jcont_%d.png" % (iexp)), format='png')

    def plotFCorCont(self, iexp):
        delta = 300.
        if (self.ccdSet.size() > 10):
            x = numpy.arange(-18000., 18000., delta)
            y = numpy.arange(-18000., 18000., delta)
            levels = numpy.linspace(0.72, 1.28, 36)
        else:
            x = numpy.arange(-6000., 6000., delta)
            y = numpy.arange(-6000., 6000., delta)
            levels = numpy.linspace(0.86, 1.14, 36)
        X, Y = numpy.meshgrid(x, y)
        Z = numpy.zeros((len(X),len(Y)))

        for j in range(len(Y)):
            for i in range(len(X)):
                Z[i][j] = 10**(-0.4*self.ffpSet[iexp].eval(X[i][j], Y[i][j]))
        mean = math.floor(Z[len(X)/2][len(Y)/2] * 10 + 0.5) / 10.
        levels = numpy.linspace(mean-0.2, mean+0.2, 41)

        plt.clf()
        plt.contourf(X, Y, Z, levels=levels)
        plt.colorbar()
        plt.title('%d' % (iexp))

        try:
            x0 = self.coeffSet[iexp].x0
            y0 = self.coeffSet[iexp].y0
        except:
            x0 = 0.0
            y0 = 0.0
        self.plotCcd(x0, y0)
        
        plt.savefig(os.path.join(self.outputDir, "fcont_%d.png" % (iexp)), format='png')

    def plotResPosArrow2D(self, iexp):
        _xm = []
        _ym = []
        _dxm = []
        _dym = []
        for m in self.matchVec:
            if (m.good == True and m.iexp == iexp):
                _xm.append(m.u)
                _ym.append(m.v)
                _dxm.append((m.xi_fit - m.xi) * 3600)
                _dym.append((m.eta_fit - m.eta) * 3600)
        _xs = []
        _ys = []
        _dxs = []
        _dys = []
        if (self.sourceVec.size() != 0):
            for s in self.sourceVec:
                if (s.good == True and s.iexp == iexp):
                    _xs.append(s.u)
                    _ys.append(s.v)
                    _dxs.append((s.xi_fit - s.xi) * 3600)
                    _dys.append((s.eta_fit - s.eta) * 3600)

        xm = numpy.array(_xm)
        ym = numpy.array(_ym)
        dxm = numpy.array(_dxm)
        dym = numpy.array(_dym)
        xs = numpy.array(_xs)
        ys = numpy.array(_ys)
        dxs = numpy.array(_dxs)
        dys = numpy.array(_dys)

        plt.clf()
        plt.rc('text', usetex=USETEX)

        q = plt.quiver(xm, ym, dxm, dym, units='inches', angles='xy', scale=1, color='green')
        if len(ym) != 0 and ym.max() > 5000:
            plt.quiverkey(q, 0, 19000, 0.1, "0.1 arcsec", coordinates='data', color='black')
        else:
            plt.quiverkey(q, 0,  4500, 0.1, "0.1 arcsec", coordinates='data', color='black')
        plt.quiver(xs, ys, dxs, dys, units='inches', angles='xy', scale=1, color='red')

        self.plotCcd(self.coeffSet[iexp].x0, self.coeffSet[iexp].y0)
        plt.axes().set_aspect('equal')

        plt.savefig(os.path.join(self.outputDir, "ResPosArrow2D_%d.png" % (iexp)), format='png')

    def clippedStd(self, a, n):
        aa = list()
        for v in a:
            if v == v:
                aa.append(v)
        aa = numpy.array(aa)

        avg = aa.mean()
        std = aa.std()
        for i in range(n):
            b = aa[numpy.fabs(aa-avg) < 2.1*std]
            avg = b.mean()
            std = b.std()

        b = aa[numpy.fabs(aa-avg) < 2.1*std]
        avg = b.mean()
        std = b.std()
            
        return [std, avg, len(b)]

    def plotResPosScatter(self):
        _x = []
        _y = []
        _xbad = []
        _ybad = []
        _xm = []
        _ym = []
        f = open(os.path.join(self.outputDir, "dpos.dat"), "wt")
        for m in self.matchVec:
            if (m.good == True):
                _x.append((m.xi_fit - m.xi) * 3600)
                _y.append((m.eta_fit - m.eta) * 3600)
                _xm.append((m.xi_fit - m.xi) * 3600)
                _ym.append((m.eta_fit - m.eta) * 3600)
                f.write("m %f %f %f %f %f %f 1\n" % (m.xi_fit, m.eta_fit,
                                                     m.xi, m.eta, m.u, m.v))
            else:
                _xbad.append((m.xi_fit - m.xi) * 3600)
                _ybad.append((m.eta_fit - m.eta) * 3600)
                f.write("m %f %f %f %f %f %f 0\n" % (m.xi_fit, m.eta_fit,
                                                     m.xi, m.eta, m.u, m.v))
        _xs = []
        _ys = []
        if (self.sourceVec.size() != 0):
            for s in self.sourceVec:
                if (s.good == True):
                    _x.append((s.xi_fit - s.xi) * 3600)
                    _y.append((s.eta_fit - s.eta) * 3600)
                    _xs.append((s.xi_fit - s.xi) * 3600)
                    _ys.append((s.eta_fit - s.eta) * 3600)
                    f.write("s %f %f %f %f %f %f 1\n" % (s.xi_fit, s.eta_fit,
                                                         s.xi, s.eta, s.u, s.v))
                else:
                    _xbad.append((s.xi_fit - s.xi) * 3600)
                    _ybad.append((s.eta_fit - s.eta) * 3600)
                    f.write("s %f %f %f %f %f %f 0\n" % (s.xi_fit, s.eta_fit,
                                                         s.xi, s.eta, s.u, s.v))
        f.close()

        d_xi = numpy.array(_x)
        d_eta = numpy.array(_y)
        d_xi_m = numpy.array(_xm)
        d_eta_m = numpy.array(_ym)
        d_xi_s = numpy.array(_xs)
        d_eta_s = numpy.array(_ys)
        d_xi_bad = numpy.array(_xbad)
        d_eta_bad = numpy.array(_ybad)

        xi_std,  xi_mean,  xi_n  = self.clippedStd(d_xi, 2)
        eta_std, eta_mean, eta_n = self.clippedStd(d_eta, 2)
        xi_std_m,  xi_mean_m,  xi_n_m  = self.clippedStd(d_xi_m, 2)
        eta_std_m, eta_mean_m, eta_n_m = self.clippedStd(d_eta_m, 2)
        xi_std_s,  xi_mean_s,  xi_n_s  = self.clippedStd(d_xi_s, 2)
        eta_std_s, eta_mean_s, eta_n_s = self.clippedStd(d_eta_s, 2)

        plt.clf()
        plt.rc('text', usetex=USETEX)

        plt.subplot2grid((5,6),(1,0), colspan=4, rowspan=4)
        plt.plot(d_xi_bad, d_eta_bad, 'k,', markeredgewidth=0)
        plt.plot(d_xi_m, d_eta_m, 'g,', markeredgewidth=0)
        plt.plot(d_xi_s, d_eta_s, 'r,', markeredgewidth=0)
        plt.xlim(-0.5, 0.5)
        plt.ylim(-0.5, 0.5)

        plt.xlabel(r'$\Delta\xi$ (arcsec)')
        plt.ylabel(r'$\Delta\eta$ (arcsec)')

        bins = numpy.arange(-0.5, 0.5, 0.01) + 0.005

        ax = plt.subplot2grid((5,6),(0,0), colspan=4)
        if self.sourceVec.size() != 0:
            plt.hist([d_xi, d_xi_m, d_xi_s], bins=bins, normed=False, histtype='step')
        else:
            plt.hist([d_xi, d_xi_m], bins=bins, normed=False, histtype='step')
        plt.text(0.75, 0.7, r"$\sigma=$%5.3f" % (xi_std), transform=ax.transAxes, color='blue')
        plt.text(0.75, 0.5, r"$\sigma=$%5.3f" % (xi_std_m), transform=ax.transAxes, color='green')
        y = mlab.normpdf(bins, xi_mean_m, xi_std_m)
        plt.plot(bins, y*xi_n_m*0.01, 'g:')
        if self.sourceVec.size() != 0:
            plt.text(0.75, 0.3, r"$\sigma=$%5.3f" % (xi_std_s), transform=ax.transAxes, color='red')
            y = mlab.normpdf(bins, xi_mean_s, xi_std_s)
            plt.plot(bins, y*xi_n_s*0.01, 'r:')
        plt.xlim(-0.5, 0.5)

        ax = plt.subplot2grid((5,6),(1,4), rowspan=4)
        plt.hist(d_eta, bins=bins, normed=False, orientation='horizontal', histtype='step')
        plt.hist(d_eta_m, bins=bins, normed=False, orientation='horizontal', histtype='step')
        if self.sourceVec.size() != 0:
            plt.hist(d_eta_s, bins=bins, normed=False, orientation='horizontal', histtype='step')
        plt.text(0.7, 0.25, r"$\sigma=$%5.3f" % (eta_std), rotation=270, transform=ax.transAxes, color='blue')
        plt.text(0.5, 0.25, r"$\sigma=$%5.3f" % (eta_std_m), rotation=270, transform=ax.transAxes, color='green')
        y = mlab.normpdf(bins, eta_mean_m, eta_std_m)
        plt.plot(y*eta_n_m*0.01, bins, 'g:')
        if self.sourceVec.size() != 0:
            plt.text(0.3, 0.25, r"$\sigma=$%5.3f" % (eta_std_s), rotation=270, transform=ax.transAxes, color='red')
            y = mlab.normpdf(bins, eta_mean_s, eta_std_s)
            plt.plot(y*eta_n_s*0.01, bins, 'r:')
        plt.xticks(rotation=270)
        plt.yticks(rotation=270)
        plt.ylim(-0.5, 0.5)

        plt.savefig(os.path.join(self.outputDir, "ResPosScatter.png"), format='png')

    def plotMdM(self):
        _dmag_m = []
        _dmag_cat_m = []
        _dmag_s = []
        _dmag_a = []
        _dmag_bad = []
        _dmag_cat_bad = []
        _mag0_m = []
        _mag_cat_m = []
        _mag0_s = []
        _mag0_bad = []
        _mag_cat_bad = []
        f = open(os.path.join(self.outputDir, 'dmag.dat'), 'wt')
        for m in self.matchVec:
            if (m.good == True and m.mag != -9999 and m.jstar != -1 and m.mag0 != -9999 and m.mag_cat != -9999):
                mag = m.mag
                mag0 = m.mag0
                mag_cat = m.mag_cat
                exp_cor = -2.5 * math.log10(self.fexp[m.iexp])
                chip_cor = -2.5 * math.log10(self.fchip[m.ichip])
                gain_cor = self.ffpSet[m.iexp].eval(m.u, m.v)
                mag_cor = mag + exp_cor + chip_cor + gain_cor
                diff = mag_cor - mag0
                _dmag_m.append(diff)
                _dmag_a.append(diff)
                _mag0_m.append(mag0)
                _dmag_cat_m.append(mag_cor - mag_cat)
                _mag_cat_m.append(mag_cat)
                f.write("m %f %f %f %f %f 1\n" % (mag_cor, mag0, mag_cat,
                                                  m.u, m.v))
            else:
                mag = m.mag
                mag0 = m.mag0
                mag_cat = m.mag_cat
                exp_cor = -2.5 * math.log10(self.fexp[m.iexp])
                chip_cor = -2.5 * math.log10(self.fchip[m.ichip])
                gain_cor = self.ffpSet[m.iexp].eval(m.u, m.v)
                mag_cor = mag + exp_cor + chip_cor + gain_cor
                diff = mag_cor - mag0
                _dmag_bad.append(diff)
                _mag0_bad.append(mag0)
                _dmag_cat_bad.append(mag_cor - mag_cat)
                _mag_cat_bad.append(mag_cat)
                f.write("m %f %f %f %f %f 0\n" % (mag_cor, mag0, mag_cat,
                                                  m.u, m.v))
        if self.sourceVec.size() != 0:
            for s in self.sourceVec:
                if (s.good == True and s.mag != -9999 and s.jstar != -1):
                    mag = s.mag
                    mag0 = s.mag0
                    exp_cor = -2.5 * math.log10(self.fexp[s.iexp])
                    chip_cor = -2.5 * math.log10(self.fchip[s.ichip])
                    gain_cor = self.ffpSet[s.iexp].eval(s.u, s.v)
                    mag_cor = mag + exp_cor + chip_cor + gain_cor
                    diff = mag_cor - mag0
                    _dmag_s.append(diff)
                    _dmag_a.append(diff)
                    _mag0_s.append(mag0)
                    f.write("s %f %f %f %f %f 1\n" % (mag_cor, mag0, -9999,
                                                      s.u, s.v))
                else:
                    mag = s.mag
                    mag0 = s.mag0
                    exp_cor = -2.5 * math.log10(self.fexp[s.iexp])
                    chip_cor = -2.5 * math.log10(self.fchip[s.ichip])
                    gain_cor = self.ffpSet[s.iexp].eval(s.u, s.v)
                    mag_cor = mag + exp_cor + chip_cor + gain_cor
                    diff = mag_cor - mag0
                    _dmag_bad.append(diff)
                    _mag0_bad.append(mag0)
                    f.write("s %f %f %f %f %f 0\n" % (mag_cor, mag0, -9999,
                                                      s.u, s.v))
        f.close()

        d_mag_m = numpy.array(_dmag_m)
        d_mag_cat_m = numpy.array(_dmag_cat_m)
        d_mag_s = numpy.array(_dmag_s)
        d_mag_a = numpy.array(_dmag_a)
        d_mag_bad = numpy.array(_dmag_bad)
        d_mag_cat_bad = numpy.array(_dmag_cat_bad)
        mag0_m = numpy.array(_mag0_m)
        mag_cat_m = numpy.array(_mag_cat_m)
        mag0_s = numpy.array(_mag0_s)
        mag0_bad = numpy.array(_mag0_bad)
        mag_cat_bad = numpy.array(_mag_cat_bad)

        mag_std_m, mag_mean_m, mag_n_m  = self.clippedStd(d_mag_m, 3)
        mag_std_s, mag_mean_s, mag_n_s  = self.clippedStd(d_mag_s, 3)
        mag_std_a, mag_mean_a, mag_n_a  = self.clippedStd(d_mag_a, 3)
        mag_cat_std_m, mag_cat_mean_m, mag_cat_n_m  = self.clippedStd(d_mag_cat_m, 3)

        plt.clf()
        plt.rc('text', usetex=USETEX)

        plt.subplot2grid((5,6),(1,0), colspan=4, rowspan=4)
        plt.plot(mag0_bad, d_mag_bad, 'k,', markeredgewidth=0)
        plt.plot(mag_cat_m, d_mag_cat_m, 'c,', markeredgewidth=0)
        if self.sourceVec.size() != 0:
            plt.plot(mag0_s, d_mag_s, 'r,', markeredgewidth=0)
        plt.plot(mag0_m, d_mag_m, 'g,', markeredgewidth=0)
        plt.plot([15,25], [0,0], 'k--')
        plt.xlim(15, 25)
        plt.ylim(-0.25, 0.25)
        plt.ylabel(r'$\Delta mag$ (mag)')

        bins = numpy.arange(-0.25, 0.25, 0.005) + 0.0025
        bins2 = numpy.arange(-0.25, 0.25, 0.05) + 0.025

        ax = plt.subplot2grid((5,6),(1,4), rowspan=4)
        plt.hist(d_mag_a, bins=bins, normed=False, orientation='horizontal', histtype='step')
        plt.hist(d_mag_m, bins=bins, normed=False, orientation='horizontal', histtype='step')
        if self.sourceVec.size() != 0:
            plt.hist(d_mag_s, bins=bins, normed=False, orientation='horizontal', histtype='step')
        plt.hist(d_mag_cat_m, bins=bins2, normed=False, orientation='horizontal', histtype='step')
        plt.text(0.7, 0.25, r"$\sigma=$%5.3f" % (mag_std_a), rotation=270, transform=ax.transAxes, color='blue')
        plt.text(0.5, 0.25, r"$\sigma=$%5.3f" % (mag_std_m), rotation=270, transform=ax.transAxes, color='green')
        plt.text(0.7, 0.90, r"$\sigma=$%5.3f" % (mag_cat_std_m), rotation=270, transform=ax.transAxes, color='cyan')
        y = mlab.normpdf(bins, mag_mean_m, mag_std_m)
        plt.plot(y*mag_n_m*0.005, bins, 'g:')
        if self.sourceVec.size() != 0:
            plt.text(0.3, 0.25, r"$\sigma=$%5.3f" % (mag_std_s), rotation=270, transform=ax.transAxes, color='red')
            y = mlab.normpdf(bins, mag_mean_s, mag_std_s)
            plt.plot(y*mag_n_s*0.005, bins, 'r:')
        y = mlab.normpdf(bins, mag_cat_mean_m, mag_cat_std_m)
        plt.plot(y*mag_cat_n_m*0.05, bins, 'c:')
        plt.xticks(rotation=270)
        plt.yticks(rotation=270)
        plt.ylim(-0.25, 0.25)

        plt.savefig(os.path.join(self.outputDir, "MdM.png"), format='png')

    def plotPosDPos(self):
        _xi = []
        _eta = []
        _x = []
        _y = []
        for m in self.matchVec:
            if (m.good == True):
                _x.append((m.xi_fit - m.xi) * 3600)
                _y.append((m.eta_fit - m.eta) * 3600)
                _xi.append(m.xi * 3600)
                _eta.append(m.eta * 3600)
        if (self.sourceVec.size() != 0):
            for s in self.sourceVec:
                if (s.good == True):
                    _x.append((s.xi_fit - s.xi) * 3600)
                    _y.append((s.eta_fit - s.eta) * 3600)
                    _xi.append(s.xi * 3600)
                    _eta.append(s.eta * 3600)

        xi = numpy.array(_xi)
        eta = numpy.array(_eta)
        d_xi = numpy.array(_x)
        d_eta = numpy.array(_y)

        plt.clf()
        plt.rc('text', usetex=USETEX)

        plt.subplot(2, 2, 1)
        plt.plot(xi, d_xi, ',', markeredgewidth=0)
        plt.xlabel(r'$\xi$ (arcsec)')
        plt.ylabel(r'$\Delta\xi$ (arcsec)')

        plt.subplot(2, 2, 3)
        plt.plot(xi, d_eta, ',', markeredgewidth=0)
        plt.xlabel(r'$\xi$ (arcsec)')
        plt.ylabel(r'$\Delta\eta$ (arcsec)')

        plt.subplot(2, 2, 2)
        plt.plot(eta, d_xi, ',', markeredgewidth=0)
        plt.xlabel(r'$\eta$ (arcsec)')
        plt.ylabel(r'$\Delta\xi$ (arcsec)')

        plt.subplot(2, 2, 4)
        plt.plot(eta, d_xi, ',', markeredgewidth=0)
        plt.xlabel(r'$\eta$ (arcsec)')
        plt.ylabel(r'$\Delta\eta$ (arcsec)')

        plt.savefig(os.path.join(self.outputDir, "PosDPos.png"), format='png')

    def plotResFlux(self):
        _dmag = []
        _iexp = []
        _ichip = []
        _r = []
        for m in self.matchVec:
            if (m.good == True and m.mag != -9999 and m.jstar != -1):
                mag = m.mag
                mag0 = m.mag0
                exp_cor = -2.5 * math.log10(self.fexp[m.iexp])
                chip_cor = -2.5 * math.log10(self.fchip[m.ichip])
                gain_cor = self.ffpSet[m.iexp].eval(m.u, m.v)
                mag_cor = mag + exp_cor + chip_cor + gain_cor
                diff = mag_cor - mag0
                _dmag.append(diff)
                _iexp.append(m.iexp)
                _ichip.append(m.ichip)

        d_mag = numpy.array(_dmag)
        iexp = numpy.array(_iexp)
        ichip = numpy.array(_ichip)

        mag_std = self.clippedStd(d_mag, 3)[0]

        _r = []
        _dm = []
        for ccd in self.ccdSet.values():
            w = measMosaic.getWidth(ccd)
            h = measMosaic.getHeight(ccd)

            _x0 = measMosaic.getCenterInFpPixels(ccd)[0] + 0.5*w
            _y0 = measMosaic.getCenterInFpPixels(ccd)[1] + 0.5*h

            _r.append(math.sqrt(_x0*_x0 + _y0*_y0))
            _dm.append(-2.5 * math.log10(self.fchip[int(ccd.getSerial())]))

        r = numpy.array(_r)
        dm = numpy.array(_dm)

        plt.clf()
        plt.rc('text', usetex=USETEX)

        ax = plt.subplot(2, 2, 1)
        plt.hist(d_mag, bins=100, normed=True, histtype='step')
        plt.text(0.1, 0.7, r"$\sigma=$%7.5f" % (mag_std), transform=ax.transAxes)
        plt.xlabel(r'$\Delta mag$ (mag)')

        ax = plt.subplot(2, 2, 2)
        plt.plot(r, dm, 'o')
        plt.xlabel(r'Distance from center (pixel)')
        plt.ylabel(r'Offset in magnitude')

        ax = plt.subplot(2, 2, 3)
        plt.plot(iexp, d_mag, ',', markeredgewidth=0)
        plt.xlabel(r'Exposure ID')
        plt.ylabel(r'$\Delta mag$ (mag)')
        plt.xlim(iexp.min()-1, iexp.max()+1)
        plt.ylim(-0.2, 0.2)

        ax = plt.subplot(2, 2, 4)
        plt.plot(ichip, d_mag, ',', markeredgewidth=0)
        plt.xlabel(r'Chip ID')
        plt.ylabel(r'$\Delta mag$ (mag)')
        plt.xlim(ichip.min()-1, ichip.max()+1)
        plt.ylim(-0.2, 0.2)

        plt.savefig(os.path.join(self.outputDir, "ResFlux.png"), format='png')

    def plotDFlux2D(self):
        _dmag = []
        _u = []
        _v = []
        for m in self.matchVec:
            if (m.good == True and m.mag != -9999 and m.jstar != -1):
                mag = m.mag
                mag0 = m.mag0
                exp_cor = -2.5 * math.log10(self.fexp[m.iexp])
                chip_cor = -2.5 * math.log10(self.fchip[m.ichip])
                gain_cor = self.ffpSet[m.iexp].eval(m.u, m.v)
                mag_cor = mag + exp_cor + chip_cor + gain_cor
                diff = mag_cor - mag0
                _dmag.append(diff)
                _u.append(m.u)
                _v.append(m.v)

        d_mag = numpy.array(_dmag)
        u = numpy.array(_u)
        v = numpy.array(_v)

        s = numpy.absolute(d_mag) * 10

        u1 = [u[i] for i in range(len(d_mag)) if d_mag[i] > 0]
        v1 = [v[i] for i in range(len(d_mag)) if d_mag[i] > 0]
        s1 = [math.fabs(d_mag[i])*20 for i in range(len(d_mag)) if d_mag[i] > 0]
        u2 = [u[i] for i in range(len(d_mag)) if d_mag[i] < 0]
        v2 = [v[i] for i in range(len(d_mag)) if d_mag[i] < 0]
        s2 = [math.fabs(d_mag[i])*20 for i in range(len(d_mag)) if d_mag[i] < 0]

        plt.clf()
        plt.rc('text', usetex=USETEX)

        plt.scatter(u1, v1, s1, color='blue')
        plt.scatter(u2, v2, s2, color='red')
        plt.axes().set_aspect('equal')

        plt.savefig(os.path.join(self.outputDir, "DFlux2D.png"), format='png')

    def outputDiagWcs(self):
        self.log.info("Output Diagnostic Figures...")

        if not os.path.isdir(self.outputDir):
            os.makedirs(self.outputDir)

        f = open(os.path.join(self.outputDir, "coeffs.dat"), "wt")
        for iexp in self.coeffSet.keys():
            c = self.coeffSet[iexp]
            f.write("%ld %12.5e %12.5e\n" % (iexp, c.A,  c.D));
            f.write("%ld %12.5f %12.5f\n" % (iexp, c.x0, c.y0));
            for k in range(c.getNcoeff()):
                f.write("%ld %15.8e %15.8e %15.8e %15.8e\n" % (iexp, c.get_a(k), c.get_b(k), c.get_ap(k), c.get_bp(k)));
        f.close()

        f = open(os.path.join(self.outputDir, "ccd.dat"), "wt")
        for ichip in self.ccdSet.keys():
            ccd = self.ccdSet[ichip]
            center = measMosaic.getCenterInFpPixels(ccd)
            f.write("%3ld %10.3f %10.3f %10.7f\n" % (ichip, center[0], center[1], measMosaic.getYaw(ccd)))
        f.close()

        for iexp in self.coeffSet.keys():
            self.plotJCont(iexp)
            self.plotResPosArrow2D(iexp)

        self.plotResPosScatter()
        self.plotPosDPos()

    def outputDiagFlux(self):
        self.log.info("Output Diagnostic Figures...")

        if not os.path.isdir(self.outputDir):
            os.makedirs(self.outputDir)

        for iexp in self.wcsDic.keys():
            self.plotFCorCont(iexp)

        f = open(os.path.join(self.outputDir, "ccdScale.dat"), "wt")
        for ichip in self.fchip.keys():
            scale = self.fchip[ichip]
            f.write("%3ld %6.3f\n" % (ichip, scale))
        f.close()

        self.plotMdM()
        self.plotResFlux()
        self.plotDFlux2D()

    def flagSuspect(self, allMat, allSource, wcsDic):
        # Wrongly matched objects between visits will destroy ubar-calibration fitting.
        # In this method, determine median magnitude difference between visits and
        # flag (set flux to negative value to be flagged as bad object) objects which
        # show large magnitude difference from median value.
        visits = wcsDic.keys()
        for j in range(len(visits)-1):
            visit_ref = visits[j]
            for i in range(j+1, len(visits)):
                visit_targ = visits[i]
                refs = list()
                targs = list()
                mref  = list()
                mtarg = list()
                for mm in allMat:
                    j_ref = -1
                    j_targ = -1
                    for k in range(1, len(mm)):
                        if mm[k].getExp() == visit_ref:
                            j_ref = k
                        elif mm[k].getExp() == visit_targ:
                            j_targ = k
                    if j_ref != -1 and j_targ != -1 and mm[j_ref].getFlux() > 0 and mm[j_targ].getFlux() > 0:
                        refs.append(mm[j_ref])
                        targs.append(mm[j_targ])
                        mref.append(mm[j_ref].getFlux())
                        mtarg.append(mm[j_targ].getFlux())
                for ss in allSource:
                    j_ref = -1
                    j_targ = -1
                    for k in range(1, len(ss)):
                        if ss[k].getExp() == visit_ref:
                            j_ref = k
                        elif ss[k].getExp() == visit_targ:
                            j_targ = k
                    if j_ref != -1 and j_targ != -1 and ss[j_ref].getFlux() > 0 and ss[j_targ].getFlux() > 0:
                        refs.append(ss[j_ref])
                        targs.append(ss[j_targ])
                        mref.append(ss[j_ref].getFlux())
                        mtarg.append(ss[j_targ].getFlux())

                # There is no overlapping sources
                if len(mref) < 10:
                    print '%d %d' % (visit_ref, visit_targ)
                    continue

                mref = -2.5*numpy.log10(mref)
                mtarg = -2.5*numpy.log10(mtarg)

                dm = mtarg - mref
                med = numpy.median(dm)
                Q1 = numpy.percentile(dm, 10)
                Q3 = numpy.percentile(dm, 90)
                SIQR = 0.5 * (Q3 - Q1)

                del dm

                ngood = 0
                nbad  = 0
                for mr, mt, ref, targ in zip(mref, mtarg, refs, targs):
                    if math.fabs(mt-mr-med) > 3.0 * SIQR:
                        ref.setFlux(-9999)
                        targ.setFlux(-9999)
                        nbad += 1
                    else:
                        ngood += 1

                print '%d %d %6.3f %5.3f %5d %5d' % (visit_ref, visit_targ, med, SIQR, ngood, nbad)

                del mref
                del mtarg
                del refs
                del targs

    def checkOverlapWithTract(self, tractInfo, dataRefList, verbose=False):
        dataRefListExists = list()
        dataRefListOverlapWithTract = list()
        tractBBox = afwGeom.Box2D(tractInfo.getBBox())
        tractWcs = tractInfo.getWcs()
        for dataRef in dataRefList:
            try:
                if not dataRef.datasetExists('calexp_md'):
                    raise RuntimeError("no data for calexp_md %s" % (dataRef.dataId))
                md = dataRef.get('calexp_md', immediate=True)
                wcs = afwImage.makeWcs(md)

                dataRefListExists.append(dataRef)

                if self.config.requireTractOverlap:
                    naxis1, naxis2 = md.get('NAXIS1'), md.get('NAXIS2')
                    bbox = afwGeom.Box2D(afwGeom.Box2I(afwGeom.Point2I(0,0), afwGeom.Extent2I(naxis1, naxis2)))
                    overlap = False
                    for corner in bbox.getCorners():
                        if tractBBox.contains(tractWcs.skyToPixel(wcs.pixelToSky(corner))):
                            overlap = True
                            break
                    if overlap:
                        dataRefListOverlapWithTract.append(dataRef)
                    else:  # when there's no break i.e. no corner was in the tract
                        if verbose:
                            self.log.warn("Image %s does not overlap tract %s" % (dataRef.dataId, tractInfo.getId()))
                else:
                    dataRefListOverlapWithTract.append(dataRef)
            except Exception as e:
                print e

        visitListOverlapWithTract = list(set([d.dataId['visit'] for d in dataRefListOverlapWithTract]))

        dataRefListToUse = list()
        for dataRef in dataRefListExists:
            if dataRef.dataId['visit'] in visitListOverlapWithTract:
                dataRefListToUse.append(dataRef)

        return dataRefListOverlapWithTract, dataRefListToUse

    def mosaic(self, dataRefList, tractInfo, ct=None, debug=False, diagDir=".",
               diagnostics=False, snapshots=False, numCoresForReadSource=1, readTimeout=9999, verbose=False):

        self.log.info(str(self.config))

        self.outputDir = os.path.join(diagDir, "%04d" % tractInfo.getId())

        if ((diagnostics or snapshots) and not os.path.isdir(self.outputDir)):
            os.makedirs(self.outputDir)

        if self.config.nBrightest != 0:
            self.log.fatal('Config paremeter nBrightest is deprecated.')
            self.log.fatal('Please use cellSize and nStarPerCell.')
            self.log.fatal('Exiting ...')
            return []

        dataRefListOverlapWithTract, dataRefListToUse = self.checkOverlapWithTract(tractInfo, dataRefList)

        sourceSet, matchList, dataRefListUsed = self.readCatalog(dataRefListToUse, ct, numCoresForReadSource,
                                                                 readTimeout, verbose)

        dataRefListToOutput = list(set(dataRefListUsed) & set(dataRefListOverlapWithTract))

        ccdSet = self.readCcd(dataRefListUsed)

        if debug:
            for ccd in ccdSet.values():
                self.log.info(str(ccd.getId().getSerial())+" "+
                              str(ccd.getCenter().getPixels(ccd.getPixelSize()))+" "+
                              str(ccd.getOrientation().getYaw()))

        wcsDic = self.readWcs(dataRefListUsed, ccdSet)

        self.removeNonExistCcd(dataRefListUsed, ccdSet)

        if debug:
            for iexp, wcs in wcsDic.iteritems():
                self.log.info(str(iexp)+" "+str(wcs.getPixelOrigin())+" "+
                              str(wcs.getSkyOrigin().getPosition(afwGeom.degrees)))

        self.log.info("frameIds : "+str(wcsDic.keys()))
        self.log.info("ccdIds : "+str(ccdSet.keys()))

        d_lim = afwGeom.Angle(self.config.radXMatch, afwGeom.arcseconds)
        if debug:
            self.log.info("d_lim : %f" % d_lim)

        allMat, allSource =self.mergeCatalog(sourceSet, matchList, ccdSet, d_lim)

        self.log.info("Flag suspect objects")
        measMosaic.flagSuspect(allMat, allSource, wcsDic)

        if self.config.clipSourcesOutsideTract:
            tractBBox = afwGeom.Box2D(tractInfo.getBBox())
            tractWcs = tractInfo.getWcs()
            allSourceClipped = measMosaic.SourceGroup([ss for ss in allSource if tractBBox.contains(tractWcs.skyToPixel(ss[0].getSky()))])
            self.log.info("Num of allSources: %d" % (len(allSource)))
            self.log.info("Num of clipped allSources: %d" % (len(allSourceClipped)))
            allSource = allSourceClipped

        self.log.info("Make obsVec")
        nmatch  = allMat.size()
        nsource = allSource.size()
        matchVec  = measMosaic.obsVecFromSourceGroup(allMat,    wcsDic, ccdSet)
        sourceVec = measMosaic.obsVecFromSourceGroup(allSource, wcsDic, ccdSet)

        self.log.info("Solve mosaic ...")
        order = self.config.fittingOrder
        internal = self.config.internalFitting
        solveCcd = self.config.solveCcd
        allowRotation = self.config.allowRotation
        fluxFitOrder = self.config.fluxFitOrder
        chebyshev = self.config.chebyshev
        absolute = self.config.fluxFitAbsolute
        solveCcdScale = self.config.fluxFitSolveCcd
        catRMS = self.config.catRMS

        if not internal:
            sourceVec = measMosaic.ObsVec()

        if debug:
            self.log.info("order : %d" % ffp.order)
            self.log.info("internal : %r" % internal)
            self.log.info("solveCcd : %r " % solveCcd)
            self.log.info("allowRotation : %r" % allowRotation)

        self.matchVec = matchVec
        self.sourceVec = sourceVec
        self.wcsDic = wcsDic
        self.ccdSet = ccdSet

        if self.config.doSolveWcs:

            if internal:
                coeffSet = measMosaic.solveMosaic_CCD(order, nmatch, nsource,
                                                      matchVec, sourceVec,
                                                      wcsDic, ccdSet,
                                                      solveCcd, allowRotation,
                                                      verbose, catRMS,
                                                      snapshots, self.outputDir)
            else:
                coeffSet = measMosaic.solveMosaic_CCD_shot(order, nmatch, matchVec, 
                                                           wcsDic, ccdSet,
                                                           solveCcd, allowRotation,
                                                           verbose, catRMS,
                                                           snapshots, self.outputDir)

            self.coeffSet = coeffSet

            self.writeNewWcs(dataRefListToOutput)

            if diagnostics:
                self.outputDiagWcs()

            for m in matchVec:
                coeff = coeffSet[m.iexp]
                scale = coeff.pixelScale()
                m.mag -= 2.5 * math.log10(coeff.detJ(m.u, m.v) / scale**2)

            if sourceVec.size() != 0:
                for s in sourceVec:
                    coeff = coeffSet[s.iexp]
                    scale = coeff.pixelScale()
                    s.mag -= 2.5 * math.log10(coeff.detJ(s.u, s.v) / scale**2)

        else:

            wcsAll = dict()

            for dataRef in dataRefListUsed:
                frameId = '%07d-%03d' % (dataRef.dataId['visit'], dataRef.dataId['ccd'])
                md = dataRef.get('calexp_md')
                wcsAll[frameId] = afwImage.makeWcs(md)
                del md

            for m in matchVec:
                wcs = wcsAll['%07d-%03d' % (m.iexp, m.ichip)]
                scale = wcs.pixelScale().asDegrees()
                m.mag -= 2.5 * math.log10(wcs.pixArea(afwGeom.Point2D(m.x, m.y)) / scale**2)

            if sourceVec.size() != 0:
                for s in sourceVec:
                    wcs = wcsAll['%07d-%03d' % (s.iexp, s.ichip)]
                    scale = wcs.pixelScale().asDegrees()
                    s.mag -= 2.5 * math.log10(wcs.pixArea(afwGeom.Point2D(s.x, s.y)) / scale**2)

            del wcsAll

        if self.config.doSolveFlux:

            ffpSet = measMosaic.FfpSet()
            for visit in wcsDic.keys():
                ffp = measMosaic.FluxFitParams(fluxFitOrder, absolute, chebyshev)
                u_max, v_max = self.getExtent(matchVec)
                ffp.u_max = (math.floor(u_max / 10.) + 1) * 10
                ffp.v_max = (math.floor(v_max / 10.) + 1) * 10
                ffpSet[visit] = ffp

            fexp = measMosaic.map_int_float()
            fchip = measMosaic.map_int_float()

            measMosaic.fluxFit(absolute, self.config.commonFluxCorr, matchVec, nmatch, sourceVec, nsource, wcsDic, ccdSet,
                               fexp, fchip, ffpSet, solveCcdScale)

            self.ffpSet = ffpSet
            self.fexp = fexp
            self.fchip = fchip

            self.writeFcr(dataRefListToOutput)

            if diagnostics:
                self.outputDiagFlux()

        if diagnostics and self.config.doSolveWcs and self.config.doSolveFlux:
            if sourceVec.size() != 0:
                self.writeCatalog(matchVec, sourceVec, coeffSet,
                                  os.path.join(self.outputDir, "catalog.fits"))

        return wcsDic.keys()

    def writeCatalog(self, matchVec, sourceVec, coeffSet, name):
        # count number of unique objects
        idList = list()
        for m in matchVec:
            if not m.istar in idList:
                idList.append(m.istar)
        num_m = len(idList)
        idList = list()
        for s in sourceVec:
            if not s.istar in idList:
                idList.append(s.istar)
        num_s = len(idList)
        num = num_m + num_s

        ra  = numpy.zeros(num, dtype=numpy.float64)
        dec = numpy.zeros(num, dtype=numpy.float64)
        mag = numpy.zeros(num, dtype=numpy.float64)
        var = numpy.zeros(num, dtype=numpy.float64)
        err = numpy.zeros(num, dtype=numpy.float64)
        numbers = numpy.zeros(num, dtype=numpy.int32)

        numGood = 0
        for m in matchVec:
            if (not m.good or m.jstar == -1 or
                m.mag == -9999 or m.err == -9999 or
                m.mag_cat == -9999):
                continue

            index = m.istar

            if numbers[index] == 0:
                numGood += 1

            # Deproject m.{xi,eta}_fit
            crval = [coeffSet[m.iexp].A, coeffSet[m.iexp].D]
            x = math.radians(m.xi_fit)
            y = math.radians(m.eta_fit)
            radius = math.hypot(x, y)
            sinPhi, cosPhi = x/radius, y/radius
            rho = math.sqrt(1.0 + radius**2)
            sinTheta, cosTheta = 1.0/rho, radius/rho
            sinD, cosD = math.sin(crval[1]), math.cos(crval[1])
            dec[index] += math.asin(sinTheta*sinD + cosTheta*cosPhi*cosD)
            sinAlpha = cosTheta*sinPhi
            cosAlpha = -cosTheta*cosPhi*sinD + sinTheta*cosD
            ra[index] += math.atan2(sinAlpha, cosAlpha) + crval[0]

            exp_cor = -2.5 * math.log10(self.fexp[m.iexp])
            chip_cor = -2.5 * math.log10(self.fchip[m.ichip])
            gain_cor = self.ffpSet[m.iexp].eval(m.u, m.v)
            mag_cor = m.mag + exp_cor + chip_cor + gain_cor

            mag[index] += mag_cor / m.err**2
            var[index] += mag_cor * mag_cor / m.err**2
            err[index] += (1.0 / m.err**2)
            numbers[index] += 1

        # Take a mean of individual measurements
        ra /= numbers
        dec /= numbers
        mag /= err
        err = numpy.sqrt((var - mag * mag * err) / err)

        for s in sourceVec:
            if (not s.good or s.jstar == -1 or
                s.mag == -9999 or s.err == -9999):
                continue

            index = s.istar + num_m

            if numbers[index] == 0:
                numGood += 1

                # For sourceVec, fitted values are stored.
                # So simply take them.
                mag[index] = s.mag0
                ra[index] = s.ra
                dec[index] = s.dec
                err[index] = 0.0

            else:
                assert mag[index] == numpy.float64(s.mag0), "Discrepancy between solved magnitudes"
                assert ra[index] == numpy.float64(s.ra), "Discrepancy between solved positions"
                assert dec[index] == numpy.float64(s.dec), "Discrepancy between solved positions"

            # For error, calculate RMS around fitted values
            exp_cor = -2.5 * math.log10(self.fexp[s.iexp])
            chip_cor = -2.5 * math.log10(self.fchip[s.ichip])
            gain_cor = self.ffpSet[s.iexp].eval(s.u, s.v)
            mag_cor = s.mag + exp_cor + chip_cor + gain_cor
            var[index] += ((mag_cor-s.mag0)/s.err)**2
            err[index] += (1.0 / s.err**2)
            numbers[index] += 1

        err[num_m:] = numpy.sqrt(var[num_m:]/err[num_m:])

        schema = afwTable.SimpleTable.makeMinimalSchema()
        magKey = schema.addField("mag", type="F", doc="Magnitude")
        errKey = schema.addField("err", type="F", doc="Magnitude error")
        numKey = schema.addField("num", type="I", doc="Number of observations")
        catalog = afwTable.SimpleCatalog(schema)
        catalog.reserve(numGood)
        for i in range(num):
            if numbers[i] == 0:
                continue
            r = catalog.addNew()
            r.setId(i)
            r.setCoord(afwCoord.Coord(ra[i]*afwGeom.radians, dec[i]*afwGeom.radians))
            r.set(magKey, float(mag[i]))
            r.set(errKey, float(err[i]))
            r.set(numKey, int(numbers[i]))

        catalog.writeFits(name)


    def run(self, camera, butler, tract, dataRefList, debug, diagDir=".",
            diagnostics=False, snapshots=False, numCoresForReadSource=1, readTimeout=9999, verbose=False):
        self.log.info("Running self-calibration for tract %d" % tract)
        skyMap = butler.get("deepCoadd_skyMap", immediate=True)
        tractInfo = skyMap[tract]

        filters = list()
        for dataRef in dataRefList:
            if not dataRef.dataId['filter'] in filters:
                filters.append(dataRef.dataId['filter'])

        if len(filters) != 1:
            self.log.fatal("There are %d filters in input frames" % len(filters))
            return None

        if self.config.doColorTerms and self.config.photoCatName:
            ct = self.config.colorterms.getColorterm(filters[0], self.config.photoCatName)
            self.log.info('color term: '+str(ct))
        elif self.config.doColorTerms:
            ct = None
            self.log.warn("Cannot apply color term: reference catalog not specified")
        else:
            ct = None
            self.log.info("Not applying color term")

        return self.mosaic(dataRefList, tractInfo, ct, debug, diagDir, diagnostics, snapshots,
                           numCoresForReadSource, readTimeout, verbose)
