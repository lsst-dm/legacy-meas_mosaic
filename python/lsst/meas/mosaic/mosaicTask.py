#!/usr/bin/env python
#
# LSST Data Management System
# Copyright 2008-2016 AURA/LSST.
#
# This product includes software developed by the
# LSST Project (http://www.lsst.org/).
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the LSST License Statement and
# the GNU General Public License along with this program.  If not,
# see <https://www.lsstcorp.org/LegalNotices/>.
#
from __future__ import print_function
import os
import math
import numpy

import multiprocessing

import lsst.afw.geom                    as afwGeom
import lsst.afw.image                   as afwImage
import lsst.afw.math                    as afwMath
import lsst.afw.table                   as afwTable
import lsst.meas.algorithms             as measAlg
import lsst.meas.astrom                 as measAstrom
import lsst.meas.mosaic                 as measMosaic
import lsst.pex.config                  as pexConfig
import lsst.pipe.base                   as pipeBase

from lsst.log import Log
from lsst.meas.algorithms import LoadIndexedReferenceObjectsTask
from lsst.meas.base.forcedPhotCcd import PerTractCcdDataIdContainer
from lsst.pipe.tasks.colorterms import ColortermLibrary
from . import utils as mosaicUtils

class MosaicRunner(pipeBase.TaskRunner):
    """Subclass of TaskRunner for MosaicTask

    MosaicTask.runDataRef() takes a number of arguments, one of which is a list of dataRefs
    extracted from the command line (whereas most CmdLineTasks' runDataRef methods take
    single dataRef, are are called repeatedly).  This class transforms the processed
    arguments generated by the ArgumentParser into the arguments expected by
    MosaicTask.runDataRef().

    See pipeBase.TaskRunner for more information, but note that the multiprocessing
    code path does not apply, because MosaicTask.canMultiprocess == False.
    """

    @staticmethod
    def getTargetList(parsedCmd, **kwargs):
        # organize data IDs by tract
        refListDict = {}
        for ref in parsedCmd.id.refList:
            refListDict.setdefault(ref.dataId["tract"], []).append(ref)
        # we call run() once with each tract
        return [(refListDict[tract],
                 parsedCmd.camera,
                 parsedCmd.butler,
                 tract,
                 parsedCmd.debug,
                 parsedCmd.diagDir,
                 parsedCmd.diagnostics,
                 parsedCmd.snapshots,
                 parsedCmd.numCoresForReadSource,
                 parsedCmd.readTimeout,
                 ) for tract in sorted(refListDict)]

    def __call__(self, args):
        task = self.TaskClass(config=self.config, log=self.log)
        result = task.runDataRef(*args)
        return pipeBase.Struct(exitStatus=0)

class MosaicConfig(pexConfig.Config):
    nBrightest = pexConfig.Field(
        doc="number of stars used for fitting per exposure",
        dtype=int,
        default=0)
    cellSize = pexConfig.Field(
        doc="size of cell used to select stars (pixels)",
        dtype=int,
        default=512,
        check = lambda x: x >= 128)
    nStarPerCell = pexConfig.Field(
        doc = "number of stars per cell",
        dtype = int,
        default = 5)
    radXMatch = pexConfig.RangeField(
        doc="radius to cross-match objects between expsoures in arcsec",
        dtype=float,
        default=1.0, min=0.1)
    fittingOrder = pexConfig.RangeField(
        doc="fitting order",
        dtype=int,
        default=5, min=2)
    internalFitting = pexConfig.Field(
        doc="Use stars without catalog matching for fitting?",
        dtype=bool,
        default=True)
    solveCcd = pexConfig.Field(
        doc="Solve CCD alignment?",
        dtype=bool,
        default=True)
    allowRotation = pexConfig.Field(
        doc="Solve rotation?",
        dtype=bool,
        default=True)
    catRMS = pexConfig.Field(
        doc="Positional error in reference catalog (degree)",
        dtype=float,
        default=0.040/3600.)
    chebyshev = pexConfig.Field(
        doc="Use Chebyshev polynomials for flux fitting?",
        dtype=bool,
        default=True)
    fluxFitOrder = pexConfig.RangeField(
        doc="flux fitting order",
        dtype=int,
        default=5, min=0)
    fluxFitAbsolute = pexConfig.Field(
        doc="Fit to catalog flux?",
        dtype=bool,
        default=False)
    fluxFitSolveCcd = pexConfig.Field(
        doc="Solve for per CCD flux scale?",
        dtype=bool,
        default=False)
    minNumMatch = pexConfig.RangeField(
        doc="Minimum number of matches in CCD to be used.",
        dtype=int,
        default=0, min=0)
    numSourceMerge = pexConfig.RangeField(
        doc="Minimum number of sources to be merged.",
        dtype=int,
        default=2, min=0)
    requireTractOverlap = pexConfig.Field(
        doc="If True, ignore CCDs that don't overlap the current tract",
        dtype=bool,
        default=True)
    clipSourcesOutsideTract = pexConfig.Field(
        doc="If True, unmatched sources outside of tract will not be used as constraints",
        dtype=bool,
        default=True)
    loadAstrom = pexConfig.ConfigurableField(
        doc="Configuration for astrometry reference object loading",
        target=LoadIndexedReferenceObjectsTask)
    doColorTerms = pexConfig.Field(
        doc="Apply color terms as part of solution?",
        dtype=bool,
        default=True)
    doSolveWcs = pexConfig.Field(
        doc="Solve distortion and wcs?",
        dtype=bool,
        default=True)
    doSolveFlux = pexConfig.Field(
        doc="Solve flux correction?",
        dtype=bool,
        default=True)
    commonFluxCorr = pexConfig.Field(
        doc="Is flux correction common between exposures?",
        dtype=bool,
        default=True)
    colorterms = pexConfig.ConfigField(
        doc="Color term library",
        dtype=ColortermLibrary)
    photoCatName = pexConfig.Field(
        doc="Name of photometric reference catalog; used to select a color term dict in colorterm library.",
        default="ps1_pv3_3pi_20170110",
        dtype=str,
        optional=True)
    includeSaturated = pexConfig.Field(
        doc="If True, saturated objects will also be used for mosaicking.",
        dtype=bool,
        default=False)
    extendednessForStarSelection = pexConfig.Field(
        doc="Extendedness for star selection",
        dtype=str,
        default="base_ClassificationExtendedness_value")
    saturatedForStarSelection = pexConfig.Field(
        doc="Saturated flag for star selection",
        dtype=str,
        default="base_PixelFlags_flag_saturated")
    psfStarForStarSelection = pexConfig.Field(
        doc="PSF star flag for star selection",
        dtype=str,
        default="calib_psf_used")
    calibStarForStarSelection = pexConfig.Field(
        doc="Calibration star detected as an icSrc flag for star selection",
        dtype=str,
        default="calib_detected")
    parentForStarSelection = pexConfig.Field(
        doc="Does souce have a parent? For star selection",
        dtype=str,
        default="parent")
    nChildForStarSelection = pexConfig.Field(
        doc="Does souce have any children? For star selection",
        dtype=str,
        default="deblend_nChild")
    coaddName = pexConfig.Field(
        doc="Type of coadd being produced; used to select the correct SkyMap.",
        dtype=str,
        default="deep")
    srcSchemaMap = pexConfig.DictField(
        doc="Mapping between different stack (e.g. HSC vs. LSST) schema names",
        keytype=str,
        itemtype=str,
        default=None,
        optional=True)
    allowMixedFilters = pexConfig.Field(dtype=bool, default=False, doc="Allow multiple filters in input?")
    flagsToAlias = pexConfig.DictField(
        doc="List of flags to alias to old, pre-RFC-498, names for backwards compatibility",
        keytype=str,
        itemtype=str,
        default={"calib_psf_used": "calib_psfUsed", "calib_psf_candidate": "calib_psfCandidate",
                 "calib_astrometry_used": "calib_astrometryUsed"})

    def setDefaults(self):
        self.loadAstrom.ref_dataset_name = "ps1_pv3_3pi_20170110"


class SourceReader(object):
    """ Object to read source catalog.
    """

    def __init__(self, cterm, config):
        self.cterm  = cterm
        self.config = config

    def selectStars(self, sources, includeSaturated=False):
        """ Return a list of stellar like objects selected from input sources

        Stellarity will be judged based mainly on extendedness (base_ClassificationExtendedness_value).
        If an object is used to determine PSF (calib_psf_used == True), it will be included.
        Blended objects (with either parent or nChild > 0) will not be included by default.
        Saturated objects (base_PixelFlags_flag_saturated) will not be included by default.
        """

        if len(sources) == 0:
            return []

        psfKey = None                       # Table key for classification.psfstar
        if isinstance(sources[0], afwTable.ReferenceMatch):
            sourceList = [s[1] for s in sources]
            psfKey = sourceList[0].schema.find(self.config.psfStarForStarSelection).getKey()
        else:
            sourceList = sources

        schema = sourceList[0].schema
        schemaDict = schema.extract("*")
        parentKey = schemaDict.get(self.config.parentForStarSelection, (None,))[0]
        nChildKey = schemaDict.get(self.config.nChildForStarSelection, (None,))[0]
        extKey = schemaDict.get(self.config.extendednessForStarSelection, (None,))[0]
        satKey = schemaDict.get(self.config.saturatedForStarSelection, (None,))[0]
        calibKey = schemaDict.get(self.config.calibStarForStarSelection, (None,))[0]

        def checkStar(checkSource):
            """
            Return True if we should use this star, false otherwise.
            """
            doInclude = True
            if (extKey and checkSource.get(extKey) > 0.5) or (psfKey and not checkSource.get(psfKey)):
                doInclude = False
            # Allow point sources regardless of above conditions (i.e. used as psf or not), but not those below
            if extKey and checkSource.get(extKey) < 0.5:
                doInclude = True
            if ((calibKey and not checkSource.get(calibKey)) or
                (parentKey and checkSource.get(parentKey) > 0) or
                (nChildKey and checkSource.get(nChildKey) > 0) or
                (satKey and checkSource.get(satKey) and not includeSaturated)):
                doInclude = False

            return doInclude

        stars = [includeSource for includeSource, checkSource in zip(sources, sourceList)
                 if checkStar(checkSource)]

        return stars

    def setCatFlux(self, m, flux, fluxKey, fluxErr, fluxErrKey):
        m[0].set(fluxKey, flux)
        m[0].set(fluxErrKey, fluxErr)
        return m

    def readSrc(self, dataRef):
        """Read source catalog etc for input dataRef

        The following are returned:
        Source catalog, matched list, and wcs will be read from 'src', 'srcMatch', and 'calexp_md',
        respectively.

        NOTE: If the detector has nQuarter%4 != 0 (i.e. it is rotated w.r.t the focal plane
              coordinate system), the (x, y) pixel values of the centroid slot for the source
              catalogs are rotated such that pixel (0, 0) is the LLC (i.e. the coordinate system
              expected by meas_mosaic).

        If color transformation information is given, it will be applied to the reference flux
        of the matched list.  The source catalog and matched list will be converted to measMosaic's
        Source and SourceMatch and returned.

        The number of 'Source's in each cell defined by config.cellSize will be limited to brightest
        config.nStarPerCell.
        """

        self.log = Log.getDefaultLogger()

        dataId = dataRef.dataId

        try:
            if not dataRef.datasetExists("src"):
                raise RuntimeError("no data for src %s" % (dataId))
            if not dataRef.datasetExists("calexp_md"):
                raise RuntimeError("no data for calexp_md %s" % (dataId))

            calexp_md = dataRef.get("calexp_md", immediate=True)
            detector = dataRef.get("camera")[dataRef.dataId["ccd"]]  # OK for HSC; maybe not for other cameras
            wcs = afwGeom.makeSkyWcs(calexp_md)
            nQuarter = detector.getOrientation().getNQuarter()
            sources = dataRef.get("src", immediate=True, flags=afwTable.SOURCE_IO_NO_FOOTPRINTS)

            # Check if we are looking at HSC stack outputs: if so, no pixel rotation of sources is
            # required, but alias mapping must be set to associate HSC's schema with that of LSST.
            hscRun = mosaicUtils.checkHscStack(calexp_md)
            if hscRun is None:
                if nQuarter%4 != 0:
                    dims = afwImage.bboxFromMetadata(calexp_md).getDimensions()
                    sources = mosaicUtils.rotatePixelCoords(sources, dims.getX(), dims.getY(),
                                                            nQuarter)

            # Set some alias maps for the source catalog where needed for
            # backwards compatibility
            if self.config.srcSchemaMap and hscRun:
                aliasMap = sources.schema.getAliasMap()
                for lsstName, otherName in self.config.srcSchemaMap.items():
                    aliasMap.set(lsstName, otherName)
            if self.config.flagsToAlias and "calib_psfUsed" in sources.schema:
                aliasMap = sources.schema.getAliasMap()
                for lsstName, otherName in self.config.flagsToAlias.items():
                    aliasMap.set(lsstName, otherName)

            refObjLoader = self.config.loadAstrom.apply(butler=dataRef.getButler())
            srcMatch = dataRef.get("srcMatch", immediate=True)
            if hscRun is not None:
                # The reference object loader grows the bbox by the config parameter pixelMargin.  This
                # is set to 50 by default but is not reflected by the radius parameter set in the
                # metadata, so some matches may reside outside the circle searched within this radius
                # Thus, increase the radius set in the metadata fed into joinMatchListWithCatalog() to
                # accommodate.
                matchmeta = srcMatch.table.getMetadata()
                rad = matchmeta.getDouble("RADIUS")
                matchmeta.setDouble("RADIUS", rad*1.05, "field radius in degrees, approximate, padded")
            matches = refObjLoader.joinMatchListWithCatalog(srcMatch, sources)

            # Set the aliap map for the matched sources (i.e. the [1] attribute schema for each match)
            if self.config.srcSchemaMap is not None and hscRun is not None:
                for mm in matches:
                    aliasMap = mm[1].schema.getAliasMap()
                    for lsstName, otherName in self.config.srcSchemaMap.items():
                        aliasMap.set(lsstName, otherName)

            if hscRun is not None:
                for slot in ("PsfFlux", "ModelFlux", "ApFlux", "GaussianFlux", "Centroid", "Shape"):
                    getattr(matches[0][1].getTable(), "define" + slot)(
                        getattr(sources, "get" + slot + "Definition")())
                    # For some reason, the CalibFlux slot in sources is coming up as centroid_sdss, so
                    # set it to flux_naive explicitly
                    for slot in ("CalibFlux", ):
                        getattr(matches[0][1].getTable(), "define" + slot)("flux_naive")
            matches = [m for m in matches if m[0] is not None]
            refSchema = matches[0][0].schema if matches else None

            if self.cterm is not None and len(matches) != 0:
                # Add a "flux" field to the input schema of the first element
                # of the match and populate it with a colorterm correct flux.
                mapper = afwTable.SchemaMapper(refSchema)
                for key, field in refSchema:
                    mapper.addMapping(key)
                fluxKey = mapper.editOutputSchema().addField("flux", type=float, doc="Reference flux")
                fluxErrKey = mapper.editOutputSchema().addField("fluxErr", type=float,
                                                                  doc="Reference flux uncertainty")
                table = afwTable.SimpleTable.make(mapper.getOutputSchema())
                table.preallocate(len(matches))
                for match in matches:
                    newMatch = table.makeRecord()
                    newMatch.assign(match[0], mapper)
                    match[0] = newMatch
                primaryFluxKey = refSchema.find(refSchema.join(self.cterm.primary, "flux")).key
                secondaryFluxKey = refSchema.find(refSchema.join(self.cterm.secondary, "flux")).key
                primaryFluxErrKey = refSchema.find(refSchema.join(self.cterm.primary, "fluxErr")).key
                secondaryFluxErrKey = refSchema.find(refSchema.join(self.cterm.secondary, "fluxErr")).key
                refFlux1 = numpy.array([m[0].get(primaryFluxKey) for m in matches])
                refFlux2 = numpy.array([m[0].get(secondaryFluxKey) for m in matches])
                refFluxErr1 = numpy.array([m[0].get(primaryFluxErrKey) for m in matches])
                refFluxErr2 = numpy.array([m[0].get(secondaryFluxErrKey) for m in matches])
                refMag1 = -2.5*numpy.log10(refFlux1)
                refMag2 = -2.5*numpy.log10(refFlux2)
                refMag = self.cterm.transformMags(refMag1, refMag2)
                refFlux = numpy.power(10.0, -0.4*refMag)
                refFluxErr = self.cterm.propagateFluxErrors(refFluxErr1, refFluxErr2)
                matches = [self.setCatFlux(m, flux, fluxKey, fluxErr, fluxErrKey) for
                           m, flux, fluxErr in zip(matches, refFlux, refFluxErr) if flux == flux]
            else:
                filterName = afwImage.Filter(calexp_md).getName()
                refFluxField = measAlg.getRefFluxField(refSchema, filterName)
                refSchema.getAliasMap().set("flux", refFluxField)

            # LSST reads in a_net catalogs with flux in "janskys", so must convert back to DN.
            matches = mosaicUtils.matchJanskyToDn(matches)

            selSources = self.selectStars(sources, self.config.includeSaturated)
            selMatches = self.selectStars(matches, self.config.includeSaturated)

            retSrc = list()
            retMatch = list()

            if len(selMatches) > self.config.minNumMatch:
                naxis1, naxis2 = afwImage.bboxFromMetadata(calexp_md).getDimensions()
                if hscRun is None:
                    if nQuarter%2 != 0:
                        naxis1, naxis2 = naxis2, naxis1
                bbox = afwGeom.Box2I(afwGeom.Point2I(0, 0), afwGeom.Extent2I(naxis1, naxis2))
                cellSet = afwMath.SpatialCellSet(bbox, self.config.cellSize, self.config.cellSize)
                for s in selSources:
                    if numpy.isfinite(s.getRa().asDegrees()): # get rid of NaN
                        src = measMosaic.Source(s)
                        src.setExp(dataId["visit"])
                        src.setChip(dataId["ccd"])
                        try:
                            tmp = measMosaic.SpatialCellSource(src)
                            cellSet.insertCandidate(tmp)
                        except:
                            self.log.info("FAILED TO INSERT CANDIDATE: visit=%d ccd=%d x=%f y=%f" %
                                          (dataRef.dataId["visit"], dataRef.dataId["ccd"],
                                           src.getX(), src.getY()) + " bbox=" + str(bbox))
                for cell in cellSet.getCellList():
                    cell.sortCandidates()
                    for i, cand in enumerate(cell):
                        src = cand.getSource()
                        retSrc.append(src)
                        if i == self.config.nStarPerCell - 1:
                            break
                for m in selMatches:
                    if m[0] is not None and m[1] is not None:
                        match = (measMosaic.Source(m[0], wcs), measMosaic.Source(m[1]))
                        match[1].setExp(dataId["visit"])
                        match[1].setChip(dataId["ccd"])
                        retMatch.append(match)
            else:
                self.log.info("%8d %3d : %d/%d matches  Suspicious to wrong match. Ignore this CCD" %
                              (dataRef.dataId["visit"], dataRef.dataId["ccd"], len(selMatches), len(matches)))

        except Exception as e:
            self.log.warn("Failed to read %s: %s" % (dataId, e))
            return dataId, [None, None, None]

        return dataId, [retSrc, retMatch, wcs]

class Worker(object):
    """ Worker object for multiprocessing
    """
    def __init__(self, verbose=False):
        self.verbose = verbose

    def __call__(self, payload):
        sourceReader, dataRef = payload

        return sourceReader.readSrc(dataRef)

class MosaicTask(pipeBase.CmdLineTask):

    RunnerClass = MosaicRunner
    canMultiprocess = False
    ConfigClass = MosaicConfig
    _DefaultName = "Mosaic"

    @classmethod
    def _makeArgumentParser(cls):
        parser = pipeBase.ArgumentParser(name=cls._DefaultName)
        parser.add_id_argument("--id", "jointcal_wcs", help="data ID, with raw CCD keys + tract",
                               ContainerClass=PerTractCcdDataIdContainer)
        parser.add_argument("--diagDir", default=".", help="Directory in which to dump diagnostics")
        parser.add_argument("--diagnostics", default=False, action="store_true",
                            help="Save diagnostics plots?")
        parser.add_argument("--snapshots", default=False, action="store_true",
                            help="Save snapshots of ObsVecs during iteration?")
        parser.add_argument("--numCoresForReadSource", default=1, type=int,
                            help="Number of cores to be used for reading source catalog")
        parser.add_argument("--readTimeout", default=9999, type=float,
                            help="Timeout (sec) for reading inputs with multiple processes")
        return parser

    def readCcd(self, dataRefList):
        self.log.info("Reading CCD info ...")

        ccds = {}
        for dataRef in dataRefList:
            if dataRef.dataId["ccd"] not in ccds:
                ccd = dataRef.get("camera")[int(dataRef.dataId["ccd"])]
                ccds[dataRef.dataId["ccd"]] = ccd

        return ccds

    def getWcsForCcd(self, dataRef):
        try:
            md = dataRef.get("calexp_md")
            return afwGeom.makeSkyWcs(md)
        except Exception as e:
            print("Failed to read: %s for %s" % (e, dataRef.dataId))
            return None

    def readWcs(self, dataRefList, ccdSet):
        self.log.info("Reading WCS ...")

        wcsDic = {}
        for dataRef in dataRefList:
            if dataRef.dataId["visit"] not in wcsDic:
                if (dataRef.datasetExists("calexp") and
                    dataRef.datasetExists("src") and
                    dataRef.datasetExists("srcMatch")):
                    wcs = self.getWcsForCcd(dataRef)
                    ccd = ccdSet[dataRef.dataId["ccd"]]
                    offset = afwGeom.Extent2D(measMosaic.getCenterInFpPixels(ccd))
                    wcsDic[dataRef.dataId["visit"]] = wcs.copyAtShiftedPixelOrigin(offset)

        return wcsDic

    def removeNonExistCcd(self, dataRefList, ccdSet):
        num = dict()
        for dataRef in dataRefList:
            if dataRef.dataId["ccd"] not in num:
                num[dataRef.dataId["ccd"]] = 0
            if (dataRef.datasetExists("calexp") and
                dataRef.datasetExists("src") and
                dataRef.datasetExists("srcMatch")):
                num[dataRef.dataId["ccd"]] += 1

        for ichip in ccdSet:
            if num[ichip] == 0:
                ccdSet.erase(ichip)

    def readCatalog(self, dataRefList, ct=None, numCoresForReadSource=1, readTimeout=9999, verbose=False):
        self.log.info("Reading catalogs ...")
        self.log.info("Use %d cores for reading source catalog" % (numCoresForReadSource))

        sourceSet = []
        matchList = []

        sourceReader = SourceReader(ct, self.config)

        params = list()
        for dataRef in dataRefList:
            params.append((sourceReader, dataRef))

        if numCoresForReadSource > 1:
            pool = multiprocessing.Pool(processes=numCoresForReadSource, maxtasksperchild=1)
            worker = Worker()
            resultList = pool.map_async(worker, params).get(readTimeout)
            pool.close()
            pool.join()
        else:
            resultList = list()
            for p in params:
                sourceReader, dataRef = p
                resultList.append(sourceReader.readSrc(dataRef))

        ssVisit = dict()
        mlVisit = dict()
        dataRefListUsed = list()
        for dataId, result in resultList:
            sources, matches, wcs = result
            if sources is not None:
                if dataId["visit"] not in ssVisit:
                    ssVisit[dataId["visit"]] = list()
                    mlVisit[dataId["visit"]] = list()

                for s in sources:
                    ssVisit[dataId["visit"]].append(s)

                for m in matches:
                    mlVisit[dataId["visit"]].append(m)

                for dataRef in dataRefList:
                    if dataRef.dataId == dataId:
                        dataRefListUsed.append(dataRef)

        for visit in ssVisit:
            sourceSet.append(ssVisit[visit])
            matchList.append(mlVisit[visit])

        return sourceSet, matchList, dataRefListUsed

    def countObsInSourceGroup(self, sg):
        num = 0
        for s in sg:
            num += (len(s) - 1)

        return num

    def mergeCatalog(self, sourceSet, matchList, ccdSet, d_lim):

        self.log.info("Creating kd-tree for matched catalog ...")
        self.log.info("len(matchList) = " + str(len(matchList)) + " " +
                      str([len(matches) for matches in matchList]))
        rootMat = measMosaic.kdtreeMat(matchList)
        allMat = rootMat.mergeMat()
        self.log.info("# of allMat : %d" % self.countObsInSourceGroup(allMat))
        self.log.info("len(allMat) = %d" % len(allMat))

        self.log.info("Creating kd-tree for source catalog ...")
        self.log.info("len(sourceSet) = " + str(len(sourceSet)) + " " +
                      str([len(sources) for sources in sourceSet]))
        rootSource = measMosaic.kdtreeSource(sourceSet, rootMat, ccdSet, d_lim)
        allSource = rootSource.mergeSource(self.config.numSourceMerge)
        self.log.info("# of allSource : %d" % self.countObsInSourceGroup(allSource))
        self.log.info("len(allSource) = %d" % len(allSource))

        return allMat, allSource

    def writeNewWcs(self, dataRefList):
        self.log.info("Write New WCS ...")
        for dataRef in dataRefList:
            iexp = dataRef.dataId["visit"]
            ichip = dataRef.dataId["ccd"]
            c = measMosaic.convertCoeff(self.coeffSet[iexp], self.ccdSet[ichip]);
            wcs = measMosaic.wcsFromCoeff(c);
            calexp_md = dataRef.get("calexp_md", immediate=True)
            hscRun = mosaicUtils.checkHscStack(calexp_md)
            if hscRun is None:
                detector = dataRef.get("camera")[dataRef.dataId["ccd"]]
                nQuarter = detector.getOrientation().getNQuarter()
                if nQuarter%4 != 0:
                    dimensions = afwImage.bboxFromMetadata(calexp_md).getDimensions()
                    if nQuarter%2 != 0:
                        dimensions = afwGeom.Extent2I(dimensions.getY(), dimensions.getX())
                    wcs = measAstrom.rotateWcsPixelsBy90(wcs, 4 - nQuarter, dimensions)

            try:
                dataRef.put(wcs, "jointcal_wcs")
            except Exception as e:
                print("failed to write wcs: %s" % (e))

    def writeFcr(self, dataRefList):
        self.log.info("Write Fcr ...")
        M_LN10 = math.log(10)
        dmag = list()
        for m in self.matchVec:
            if (m.good == True and m.mag != -9999 and m.jstar != -1 and
                m.mag0 != -9999 and m.mag_cat != -9999):
                mag = m.mag
                mag_cat = m.mag_cat
                exp_cor = -2.5*math.log10(self.fexp[m.iexp])
                chip_cor = -2.5*math.log10(self.fchip[m.ichip])
                gain_cor = self.ffpSet[m.iexp].eval(m.u, m.v)
                mag_cor = mag + exp_cor + chip_cor + gain_cor
                dmag.append(mag_cor - mag_cat)
        std, mean, n  = mosaicUtils.clippedStd(numpy.array(dmag), 2.1)
        for dataRef in dataRefList:
            iexp = dataRef.dataId["visit"]
            ichip = dataRef.dataId["ccd"]
            try:
                x0 = self.coeffSet[iexp].x0
                y0 = self.coeffSet[iexp].y0
            except:
                x0 = 0.0
                y0 = 0.0
            newP = measMosaic.convertFluxFitParams(measMosaic.FluxFitParams(self.ffpSet[iexp]),
                                                   self.ccdSet[ichip], x0, y0)
            metadata = measMosaic.metadataFromFluxFitParams(newP)
            exp = afwImage.ExposureI(0,0)
            exp.getMetadata().combine(metadata)
            scale = self.fexp[iexp]*self.fchip[ichip]
            photoCalib = afwImage.makePhotoCalibFromCalibZeroPoint(1.0/scale, 1.0/scale*std*M_LN10*0.4)
            exp.setPhotoCalib(photoCalib)
            try:
                dataRef.put(exp, "fcr")
            except Exception as e:
                print("failed to write fcr: %s" % (e))

            # Write the flux fit (including Jacobian) as a PhotoCalib for
            # future compatibility with jointcal.  This is redundant with
            # the above, and should eventually supercede it.
            detector = dataRef.get("camera")[dataRef.dataId["ccd"]]
            nQuarter = detector.getOrientation().getNQuarter()
            bbox = detector.getBBox()
            try:
                # Reading the Wcs we just wrote obviously isn't efficient, but
                # it should be in the noise of the overall runtime and it
                # saves us from doing a bunch of refactoring in a fragile
                # package with no tests.
                wcs = dataRef.get("jointcal_wcs")
            except Exception as e:
                print("failed to read Wcs for PhotoCalib: %s" % (e))
                continue
            bf = measMosaic.FluxFitBoundedField(bbox, newP, wcs,
                                                zeroPoint=photoCalib.getInstFluxAtZeroMagnitude(),
                                                nQuarter=nQuarter)
            dataRef.put(photoCalib, "jointcal_photoCalib")

    def outputDiagWcs(self):
        self.log.info("Output WCS Diagnostic Figures...")

        if not os.path.isdir(self.outputDir):
            os.makedirs(self.outputDir)

        mosaicUtils.writeWcsData(self.coeffSet, self.ccdSet, self.outputDir)
        for iexp in self.coeffSet:
            mosaicUtils.plotJCont(self.ccdSet, self.coeffSet, iexp, self.outputDir)
            mosaicUtils.plotResPosArrow2D(self.ccdSet, iexp, self.matchVec, self.sourceVec, self.outputDir)

        mosaicUtils.plotResPosScatter(self.matchVec, self.sourceVec, self.outputDir)
        mosaicUtils.plotPosDPos(self.matchVec, self.sourceVec, self.outputDir)

    def outputDiagFlux(self):
        self.log.info("Output Flux Diagnostic Figures...")

        if not os.path.isdir(self.outputDir):
            os.makedirs(self.outputDir)

        mosaicUtils.writeFluxData(self.fchip, self.outputDir)

        for iexp in self.wcsDic:
            mosaicUtils.plotFCorCont(self.ccdSet, self.ffpSet, self.coeffSet, iexp, self.outputDir)

        mosaicUtils.plotMdM(self.ffpSet, self.fexp, self.fchip, self.matchVec, self.sourceVec, self.outputDir)
        mosaicUtils.plotResFlux(self.ccdSet, self.ffpSet, self.fexp, self.fchip, self.matchVec, self.sourceVec,
                                self.outputDir)
        mosaicUtils.plotDFlux2D(self.ccdSet, self.ffpSet, self.fexp, self.fchip, self.matchVec, self.outputDir)

    def flagSuspect(self, allMat, allSource, wcsDic):
        # Wrongly matched objects between visits will destroy ubar-calibration fitting.
        # In this method, determine median magnitude difference between visits and
        # flag (set flux to negative value to be flagged as bad object) objects which
        # show large magnitude difference from median value.
        visits = list(wcsDic.keys())
        for j in range(len(visits) - 1):
            visit_ref = visits[j]
            for i in range(j + 1, len(visits)):
                visit_targ = visits[i]
                refs = list()
                targs = list()
                mref  = list()
                mtarg = list()
                for mm in allMat:
                    j_ref = -1
                    j_targ = -1
                    for k in range(1, len(mm)):
                        if mm[k].getExp() == visit_ref:
                            j_ref = k
                        elif mm[k].getExp() == visit_targ:
                            j_targ = k
                    if j_ref != -1 and j_targ != -1 and mm[j_ref].getFlux() > 0 and mm[j_targ].getFlux() > 0:
                        refs.append(mm[j_ref])
                        targs.append(mm[j_targ])
                        mref.append(mm[j_ref].getFlux())
                        mtarg.append(mm[j_targ].getFlux())
                for ss in allSource:
                    j_ref = -1
                    j_targ = -1
                    for k in range(1, len(ss)):
                        if ss[k].getExp() == visit_ref:
                            j_ref = k
                        elif ss[k].getExp() == visit_targ:
                            j_targ = k
                    if j_ref != -1 and j_targ != -1 and ss[j_ref].getFlux() > 0 and ss[j_targ].getFlux() > 0:
                        refs.append(ss[j_ref])
                        targs.append(ss[j_targ])
                        mref.append(ss[j_ref].getFlux())
                        mtarg.append(ss[j_targ].getFlux())

                # There is no overlapping sources
                if len(mref) < 10:
                    print("%d %d" % (visit_ref, visit_targ))
                    continue

                mref = -2.5*numpy.log10(mref)
                mtarg = -2.5*numpy.log10(mtarg)

                dm = mtarg - mref
                med = numpy.median(dm)
                Q1 = numpy.percentile(dm, 10)
                Q3 = numpy.percentile(dm, 90)
                SIQR = 0.5*(Q3 - Q1)

                del dm

                ngood = 0
                nbad  = 0
                for mr, mt, ref, targ in zip(mref, mtarg, refs, targs):
                    if math.fabs(mt-mr-med) > 3.0*SIQR:
                        ref.setFlux(-9999)
                        targ.setFlux(-9999)
                        nbad += 1
                    else:
                        ngood += 1

                print("visit_ref visit_targ med SIQR ngood nbad")
                print("%10d %10d %6.3f %5.3f %5d %5d" % (visit_ref, visit_targ, med, SIQR, ngood, nbad))

                del mref
                del mtarg
                del refs
                del targs

    def checkOverlapWithTract(self, tractInfo, dataRefList, verbose=False):
        dataRefListExists = list()
        dataRefListOverlapWithTract = list()
        tractBBox = afwGeom.Box2D(tractInfo.getBBox())
        tractWcs = tractInfo.getWcs()
        for dataRef in dataRefList:
            try:
                if not dataRef.datasetExists("calexp_md"):
                    raise RuntimeError("no data for calexp_md %s" % (dataRef.dataId))
                md = dataRef.get("calexp_md", immediate=True)
                wcs = afwGeom.makeSkyWcs(md)

                dataRefListExists.append(dataRef)

                if self.config.requireTractOverlap:
                    naxis1, naxis2 = afwImage.bboxFromMetadata(md).getDimensions()
                    bbox = afwGeom.Box2D(afwGeom.Box2I(
                            afwGeom.Point2I(0, 0), afwGeom.Extent2I(naxis1, naxis2)))
                    overlap = False
                    for corner in bbox.getCorners():
                        if tractBBox.contains(tractWcs.skyToPixel(wcs.pixelToSky(corner))):
                            overlap = True
                            break
                    if overlap:
                        dataRefListOverlapWithTract.append(dataRef)
                    else:  # when there's no break i.e. no corner was in the tract
                        if verbose:
                            self.log.warn("Image %s does not overlap tract %s" %
                                          (dataRef.dataId, tractInfo.getId()))
                else:
                    dataRefListOverlapWithTract.append(dataRef)
            except Exception as e:
                print(e)

        visitListOverlapWithTract = list(set([d.dataId["visit"] for d in dataRefListOverlapWithTract]))

        dataRefListToUse = list()
        for dataRef in dataRefListExists:
            if dataRef.dataId["visit"] in visitListOverlapWithTract:
                dataRefListToUse.append(dataRef)

        return dataRefListOverlapWithTract, dataRefListToUse

    def run(self, dataRefList, tractInfo, ct=None, debug=False, diagDir=".",
            diagnostics=False, snapshots=False, numCoresForReadSource=1, readTimeout=9999, verbose=False):

        self.log.info(str(self.config))

        self.outputDir = os.path.join(diagDir, "%04d" % tractInfo.getId())

        if ((diagnostics or snapshots) and not os.path.isdir(self.outputDir)):
            os.makedirs(self.outputDir)

        if self.config.nBrightest != 0:
            self.log.fatal("Config paremeter nBrightest is deprecated.")
            self.log.fatal("Please use cellSize and nStarPerCell.")
            self.log.fatal("Exiting ...")
            return []

        dataRefListOverlapWithTract, dataRefListToUse = self.checkOverlapWithTract(tractInfo, dataRefList)

        sourceSet, matchList, dataRefListUsed = self.readCatalog(dataRefListToUse, ct, numCoresForReadSource,
                                                                 readTimeout, verbose)
        if not matchList:
            raise RuntimeError("No reference source matches found")

        dataRefListToOutput = list(set(dataRefListUsed) & set(dataRefListOverlapWithTract))

        ccdSet = self.readCcd(dataRefListUsed)

        if debug:
            for ccd in ccdSet.values():
                self.log.info(str(ccd.getId().getSerial()) + " " +
                              str(ccd.getCenter().getPixels(ccd.getPixelSize())) + " " +
                              str(ccd.getOrientation().getYaw()))

        wcsDic = self.readWcs(dataRefListUsed, ccdSet)

        self.removeNonExistCcd(dataRefListUsed, ccdSet)

        if debug:
            for iexp, wcs in wcsDic.items():
                self.log.info(str(iexp) + " " + str(wcs.getPixelOrigin()) + " " +
                              str(wcs.getSkyOrigin().getPosition(afwGeom.degrees)))

        self.log.info("frameIds : " + str(list(wcsDic.keys())))
        self.log.info("ccdIds : " + str(list(ccdSet.keys())))

        d_lim = afwGeom.Angle(self.config.radXMatch, afwGeom.arcseconds)
        if debug:
            self.log.info("d_lim : %f" % d_lim)

        allMat, allSource =self.mergeCatalog(sourceSet, matchList, ccdSet, d_lim)

        self.log.info("Flag suspect objects")
        measMosaic.flagSuspect(allMat, allSource, wcsDic)

        if self.config.clipSourcesOutsideTract:
            tractBBox = afwGeom.Box2D(tractInfo.getBBox())
            tractWcs = tractInfo.getWcs()
            allSourceClipped = [ss for ss in allSource if tractBBox.contains(tractWcs.skyToPixel(ss[0].getSky()))]
            self.log.info("Num of allSources: %d" % (len(allSource)))
            self.log.info("Num of clipped allSources: %d" % (len(allSourceClipped)))
            allSource = allSourceClipped

        self.log.info("Make obsVec")
        nmatch  = len(allMat)
        nsource = len(allSource)
        matchVec  = measMosaic.obsVecFromSourceGroup(allMat, wcsDic, ccdSet)
        sourceVec = measMosaic.obsVecFromSourceGroup(allSource, wcsDic, ccdSet)

        self.log.info("Solve mosaic ...")
        order = self.config.fittingOrder
        internal = self.config.internalFitting
        solveCcd = self.config.solveCcd
        allowRotation = self.config.allowRotation
        fluxFitOrder = self.config.fluxFitOrder
        chebyshev = self.config.chebyshev
        absolute = self.config.fluxFitAbsolute
        solveCcdScale = self.config.fluxFitSolveCcd
        catRMS = self.config.catRMS

        if not internal:
            sourceVec = []

        if debug:
            self.log.info("order : %d" % order)
            self.log.info("internal : %r" % internal)
            self.log.info("solveCcd : %r " % solveCcd)
            self.log.info("allowRotation : %r" % allowRotation)

        if self.config.doSolveWcs:
            if internal:
                coeffSet, matchVec, sourceVec, wcsDic, ccdSet = measMosaic.solveMosaic_CCD(order, nmatch, nsource,
                                                      matchVec, sourceVec,
                                                      wcsDic, ccdSet,
                                                      solveCcd, allowRotation,
                                                      verbose, catRMS,
                                                      snapshots, self.outputDir)
            else:
                coeffSet, matchVec, wcsDic, ccdSet = measMosaic.solveMosaic_CCD_shot(order, nmatch, matchVec,
                                                           wcsDic, ccdSet,
                                                           solveCcd, allowRotation,
                                                           verbose, catRMS,
                                                           snapshots, self.outputDir)

            self.matchVec = matchVec
            self.sourceVec = sourceVec
            self.wcsDic = wcsDic
            self.ccdSet = ccdSet
            self.coeffSet = coeffSet

            self.writeNewWcs(dataRefListToOutput)

            if diagnostics:
                self.outputDiagWcs()

            for m in matchVec:
                coeff = coeffSet[m.iexp]
                scale = coeff.pixelScale()
                m.mag -= 2.5*math.log10(coeff.detJ(m.u, m.v)/scale**2)

            if len(sourceVec) != 0:
                for s in sourceVec:
                    coeff = coeffSet[s.iexp]
                    scale = coeff.pixelScale()
                    s.mag -= 2.5*math.log10(coeff.detJ(s.u, s.v)/scale**2)

        else:

            wcsAll = dict()

            for dataRef in dataRefListUsed:
                frameId = "%07d-%03d" % (dataRef.dataId["visit"], dataRef.dataId["ccd"])
                md = dataRef.get("calexp_md")
                wcsAll[frameId] = afwGeom.makeSkyWcs(md)
                del md

            for m in matchVec:
                wcs = wcsAll["%07d-%03d" % (m.iexp, m.ichip)]
                m.mag -= 2.5*math.log10(measMosaic.computeJacobian(wcs, afwGeom.Point2D(m.x, m.y)))

            if len(sourceVec) != 0:
                for s in sourceVec:
                    wcs = wcsAll["%07d-%03d" % (s.iexp, s.ichip)]
                    s.mag -= 2.5*math.log10(measMosaic.computeJacobian(wcs, afwGeom.Point2D(s.x, s.y)))

            del wcsAll

        if self.config.doSolveFlux:

            ffpSet = {}
            for visit in wcsDic:
                ffp = measMosaic.FluxFitParams(fluxFitOrder, absolute, chebyshev)
                u_max, v_max = mosaicUtils.getExtent(matchVec)
                ffp.u_max = (math.floor(u_max/10.0) + 1)*10
                ffp.v_max = (math.floor(v_max/10.0) + 1)*10
                ffpSet[visit] = ffp

            fexp = {}
            fchip = {}

            matchVec, sourceVec, wcsDic, ccdSet, fexp, fchip, ffpSet = measMosaic.fluxFit(absolute, self.config.commonFluxCorr, matchVec, len(matchVec), sourceVec, len(sourceVec), wcsDic, ccdSet, fexp, fchip, ffpSet, solveCcdScale)

            self.ffpSet = ffpSet
            self.fexp = fexp
            self.fchip = fchip

            self.writeFcr(dataRefListToOutput)

            if diagnostics:
                self.outputDiagFlux()

        if diagnostics and self.config.doSolveWcs and self.config.doSolveFlux:
            if len(sourceVec) != 0:
                mosaicUtils.writeCatalog(coeffSet, ffpSet, fexp, fchip, matchVec, sourceVec,
                                         os.path.join(self.outputDir, "catalog.fits"))

        return list(wcsDic.keys())


    def runDataRef(self, dataRefList, camera, butler, tract, debug, diagDir=".",
                   diagnostics=False, snapshots=False, numCoresForReadSource=1,
                   readTimeout=9999, verbose=False):
        self.log.info("Running self-calibration for tract %d" % tract)
        skyMap = butler.get("deepCoadd_skyMap", immediate=True)
        tractInfo = skyMap[tract]

        filters = set(dataRef.dataId['filter'] for dataRef in dataRefList)

        if len(filters) != 1:
            self.log.warn("There are %d filters in input frames: %s" % (len(filters), ", ".join(filters)))
            if not self.config.allowMixedFilters:
                raise pipeBase.TaskError("Multiple filters found: %s" % (filters,))

        if self.config.doColorTerms and self.config.photoCatName:
            filterName = sorted(filters)[0]
            self.log.info("Using color terms for filter %s" % filterName)
            ct = self.config.colorterms.getColorterm(filterName, self.config.photoCatName)
            self.log.info("color term: " + str(ct))
        elif self.config.doColorTerms:
            ct = None
            self.log.warn("Cannot apply color term: reference catalog not specified")
        else:
            ct = None
            self.log.info("Not applying color term")

        return self.run(dataRefList, tractInfo, ct, debug, diagDir, diagnostics, snapshots,
                        numCoresForReadSource, readTimeout, verbose)
